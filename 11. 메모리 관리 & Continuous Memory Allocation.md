# 메모리 관리 (⚙주기억장치 관리)
  - ### <img src="https://user-images.githubusercontent.com/35948339/130362751-3e605809-d991-4146-b434-6ad5dacd7675.png" width=600> <br><br> CPU가 관리 ▶️ 레지스터, 캐시 <br><br> OS가 관리 ▶️ 메인 메모리, 보조기억장치
------
  - ## 메모리 계층구조
    - <img src="https://user-images.githubusercontent.com/35948339/130362873-bf68d22c-57ea-4e69-8ce2-26f1b2553295.png" width=600>
    - ### Block
      - ### 보조기억장치 🔄 주기억장치 사이의 데이터 전송 단위
      - ### 💾Size : 1 ~ 4KB
    - ### Word
      - ### 주기억장치 🔄 레지스터 사이의 데이터 전송 단위
      - ### 💾Size : 16 ~ 64 Bits <br><br> ⭐OS가 32bit, 64bit ▶️ Word 단위의 차이다⭐ <br><br> ▶️ 레지스터 하나의 크기가 32bit/64bit 이고, 메모리에서 Word 단위로 읽어온다
  - ## 🔸 Address Binding
    - ### `프로그램의 💾논리 주소를` 🔀 실제 메모리의 ⚙물리 주소로 매핑하는 작업
    - <img src="https://user-images.githubusercontent.com/35948339/130363155-481e5b6e-4e66-46e6-93cd-05c836046de4.png" width=800>
    - ### 🔸코드를 실행시키는 과정
      - ### 1️⃣ 🔹Compile time binding ▶️ Compile Time의 과정
        - ### 🔹프로세스가 메모리에 적재될 위치를 컴파일러가 알 수 있는 경우
        - ### 프로그램 전체가 메모리에 올라가야 함
      - ### 2️⃣ 🔹Load time binding ▶️ Load Time의 과정
        - ### 🔹메모리 적재 위치를 ‼Compile Time에서 모르면, 대체 가능한 상대 주소를 생성
        - ### 🔹적재 시점 (Load Time)에 시작 주소를 반영하여 사용자 코드 상의 주소를 재설정
        - ### 프로그램 전체가 메모리에 올라가야 함
      - ### 3️⃣ 🔹Run time binding ▶️ Run Time 도중에 Binding
        - ### 🔹Address Binding을 수행시간까지 연기 <br><br> 🔹프로세스가 수행 도중 다른 메모리 위치로 이동할 수 있다
        - ### HW의 도움이 필요하다
        - ### 대부분의 OS가 사용한다
-------
  - ## 🔸Dynamic Loading
    - ### 🔹모든 루틴을 교체 가능한 형태로 디스크에 저장
    - ### 🔹실제 호출 전까지는 루틴을 적재하지 않는다
      - ### ✔ 메인 프로그램만 메모리에 적재하여 수행
      - ### 루틴의 호출 시점에 Address Binding 수행
    - ### 장점 <br><br> ♻메모리 공간의 효율적 사용
------
  - ## 🔸Swapping
    - <img src="https://user-images.githubusercontent.com/35948339/130465373-d5136da4-bee2-4e86-8fdf-ad2bf6ebbf16.png" width=600>
    - ### 🔹프로세서 할당이 끝나고 수행 완료 된 프로세스는 Swap-device로 보내고 (Swap-out) <br><br> 🔹 새롭게 시작하는 프로세스는 메모리에 적재 (Swap-in)
------
# 🔸Memory Allocation
  - ## Continuous Memory Allocation (연속할당)
    - ### 💾프로세스를 하나의 연속된 메모리 공간에 할당하는 정책 <br><br> ▶️ 프로그램, 데이터, 스택 등
    - ### 🔵메모리 구성 정책
      - ### 🔹메모리에 동시에 올라갈 수 있는 프로세스 수 (Multiprogramming degree)
      - ### 🔹각 프로세스에게 할당되는 메모리 공간 크기
      - ### 🔹메모리 분할 방법
    - ## 🔸Uni-programming ▶️ 프로세스를 한번에 하나만 적재한다
      - ### 🟥문제점 <br><br> 프로그램 크기 > 메모리 크기 일 경우
      - ### ✅해결법
        - ### 🔹Overlay Structure
          - ### 💾메모리에 현재 필요한 영역만 적재 ▶ Ex. 공동 부분에 프로세스들의 필요한 부분만 적재
          - <img src="https://user-images.githubusercontent.com/35948339/130469528-0aa8b591-361f-4cde-9f6c-b7d163faf4cb.png" width=400>
          - ### 🚧사용자가 프로그램의 흐름 및 자료구조를 모두 알고 있어야 한다 <br><br> ⚠그 경계선을 정확히 알아야 교체가 가능하다
      - ### 🟥문제점 <br><br> 커널을 침범해서 프로세스를 적재할 가능성이 있다
      - <img src="https://user-images.githubusercontent.com/35948339/130469175-5af1c813-7448-4767-af87-e7b9f4ad2dc7.png" width=400>
      - ### ✅해결법 <br><br> 🚧경계 레지스터를 사용하여 커널 침범을 막는다
      - <img src="https://user-images.githubusercontent.com/35948339/130470228-9824bd2c-92d2-4b0c-b44b-f31b03ce148b.png" width=400>
      - ### ⚠프로세스를 하나만 올리기 때문에 경계 레지스터 밑 부분은 낭비 될 가능성이 높다
    - ## 🔸Multi-programming
      - ## 🔸Fixed Partition Multi-programming
        - <img src="https://user-images.githubusercontent.com/35948339/130471325-e7c09038-f5a9-448e-85b2-4f423508635e.png" width=700>
        - ### 🔹메모리 공간을 고정된 크기로 분할
        - ### 🔹각 프로세스는 하나의 Partition에 적재
        - ### 🔹Partition의 수 ▶ 프로세스의 수 (Multiprogramming degree)
        - <img src="https://user-images.githubusercontent.com/35948339/130471706-159481be-6952-4d2d-a145-2b3c6a626ae0.png" height=300>
        - ### 🚧마찬가지로 경계 레지스터를 사용하여 프로세스의 침범을 막을 수 있다.
        - ### 🔸Fragmentation (단편화)
          - ### 🔸내부 단편화
            - <img src="https://user-images.githubusercontent.com/35948339/130472380-34e35c32-60db-45be-941b-d41c7819849a.png" height=300>
            - ### ⭐Partition 크기 > Process 크기 <br><br> ❌Process 1 ▶ 10MB 낭비 / 2 ▶ 9MB 낭비 / 3 ▶ 5MB 낭비
          - ### 🔸외부 단편화
            - <img src="https://user-images.githubusercontent.com/35948339/130472753-7c894272-2299-4701-92d4-a9efe152869a.png" height=300>
            - ### ❌남은 메모리 크기가 44MB지만 연속된 공간이 아니므로, Process 4가 적재 될 수 없다❌
       - ### 🟥 Fixed Partition Multi-programming 요약
         - ### 1️⃣고정된 크기로 메모리를 미리 분할 <br><br> 2️⃣메모리 관리가 간편하지만, 메모리 공간이 낭비 될 수 있다 <br><br> 3️⃣내/외부 단편화 발생
      - ## 🔸Variable Partition Multi-programming
        - ### 🔹초기에는 전체가 하나의 영역
        - ### 🔹프로세스를 처리하는 과정에서 메모리 공간이 동적으로 분할
        - ### 🔹내부 단편화가 발생하지 않음 ❗ ▶ 필요한 만큼만 공간을 할당하기 때문에
        - ### 🔵VPM 예시
          - ### <img src="https://user-images.githubusercontent.com/35948339/130474345-6cf7da7c-06ce-4cd0-a634-add0ebb1e4d7.png" height=200> <img src="https://user-images.githubusercontent.com/35948339/130474466-a3ae7ad0-0bb9-495a-9f55-7034d0e58d0f.png" height=200> <br><br> 1️⃣초기상태에서 A B C D 적재
          - ### <img src="https://user-images.githubusercontent.com/35948339/130474690-cba20467-3630-474f-a459-03bb32f3d887.png" height=200> <img src="https://user-images.githubusercontent.com/35948339/130474768-9780ea90-d3c1-464c-a444-b4a6c15e0161.png" height=200> <br><br> 2️⃣B 반납
          - ### <img src="https://user-images.githubusercontent.com/35948339/130474834-bd4398fc-416c-47f4-a5e4-64c94608ea54.png" height=200> <img src="https://user-images.githubusercontent.com/35948339/130474874-634d1a5d-bc35-465f-8e0d-8bf1bf9152af.png" height=200> <br><br> 3️⃣E 적재
          - ### <img src="https://user-images.githubusercontent.com/35948339/130474917-43964304-6aac-46ab-aa3f-068f1605b244.png" height=200> <img src="https://user-images.githubusercontent.com/35948339/130474943-51eb2728-3f5b-49c5-b2aa-915e125677e1.png" height=200> <br><br> 4️⃣D 반납
          - ### 5️⃣ ⭐ P(5MB)를 적재 할 때, 어디에 적재하는게 좋을까? ⭐
        - ## 🔸배치 전략
          - ### 🔸First-fit (최초 적합)
            - <img src="https://user-images.githubusercontent.com/35948339/130475673-89383c46-9852-4212-8e22-f40bdfa7fb37.png" width=400> 
            - ### 🔹충분한 크기를 가진 처음 만나는 Partition 선택
            - ### ❗공간 활용률이 떨어질 수 있다
          - ### 🔸Best-fit (최적 적합)
            - ### 🔹프로세스가 들어갈 수 있는 Partition 중 가장 작은 곳 선택
            - ### 🔹탐색 시간이 오래 걸린다 ▶ 모든 Partition 탐색
            - ### 😊크기가 큰 Partition을 오래 유지 할 수 있지만 <br><br> 😂작은 크기의 Partition이 많이 발생 할 수 있다
          - ### 🔸Worst-fit (최악 적합)
            - ### 🔹프로세스가 들어갈 수 있는 Partition 중 가장 큰 곳 선택
            - ### 🔹탐색 시간이 오래 걸린다 ▶ 모든 Partition 탐색
            - ### 😊작은 Partition을 발생 줄일 수 있지만 <br><br> 😂큰 크기의 Partition 확보가 어렵다
          - ### 🔸Next-fit (순차 최초 적합)
            - ### 🔹최초 적합 전략과 유사
            - ### 🔹State table에서 마지막으로 탐색한 위치부터 탐색
            - ### 🔹메모리 영역의 사용 빈도를 균등화
        - ## 🔸공간 통합
          - ### 5️⃣ ⭐ `P(50MB)` 를 적재 할 때, 어디에 적재하는게 좋을까? ⭐
          - <img src="https://user-images.githubusercontent.com/35948339/130477247-c9c4bff3-b8ca-4db7-ab10-1ce6466fdf8a.png" width=600> 
          - ### ♻프로세스가 공간을 반납하면 연속된 빈 공간을 합친다 (✔A 나가고 합치기)
        - ## 🔸메모리 압축
          - ### 5️⃣ ⭐ P(50MB)를 적재 할 때, `당장 어디에` 적재하는게 좋을까? ⭐
          - <img src="https://user-images.githubusercontent.com/35948339/130478039-c15cfba2-92d1-4851-bbbe-a0cc1c28e3db.png" width=600> 
          - ### ♻모든 빈 공간을 하나로 통합
          - ### 💾프로세스 처리에 필요한 적재 공간 확보가 필요 할 때 수행
          - ### ⚠High Overhead <br><br> 모든 Process를 중지하고 재배치 하므로 많은 시스템 자원을 소모한다 <br><br> ‼가끔 해줘야 한다
