# Mutual Exclusion Solutions

## SW Solution
  - ## Dekker's Algorithm
    - <img src="https://user-images.githubusercontent.com/35948339/128881092-ece613f2-5dff-4eb3-ad6c-8242fd40cd66.png" width=600>
    - ### 두 개의 프로세스 ME를 보장하는 최초의 알고리즘
    - ### Version 1, 2, 3 보완한 방법
  - ## Peterson's Algorithm
    - <img src="https://user-images.githubusercontent.com/35948339/128881517-b6cd3810-650c-4ddc-b655-9286810b8a38.png" width=600>
    - ### Dekker's Algorithm 보다 간단하게 구현
  - ## Dijkstra's Algorithm
    - ### ⭐ 최초로 프로세스 N개의 ME 해결
    - ### ⭐ 실행 시간이 가장 짧은 프로세스에 CPU를 할당하는 Semaphore 방법 <br><br> ⭐ 가장 짧은 평균 대기시간 제공
    - <img src="https://user-images.githubusercontent.com/35948339/128883255-ba3a87ac-e3d7-484d-aced-9e078d982592.png" width=600>
    - ### ⭐ Dijkstra에서의 flag[]
      - ### ✔ idle : 프로세스가 임계 지역 진입을 시도하고 있지 않을 때
      - ### ✔ want-in : 프로세스의 임계 지역 진입 시도 1단계
      - ### ✔ in-CS : 프로세스의 임계 지역 진입 시도 2단계
        - ### ⭐ in-CS 안에 나 혼자 있으면 임계 영역에 들어가겠다 <br><br> ‼ 만약에 누군가 있었으면, 처음으로 다시 돌아간다
  - ## SW solution 들의 문제점
    - ### 🟥 Dijkstra Solution 처럼 빙빙 도는 현상이 목격 된다
    - ### 🟥 ➡️ 속도가 느리다
    - ### 🟥 구현이 복잡하다
    - ### ‼ ME primitive 실행 중 선점 될 가능성이 있다 ➡️ Interrupt 조절 ➡️ Overhead 발생 ‼
    - ### 🟥 Busy Waiting 발생 ➡️ 자기 차례 올 때까지, 빙빙 돌면서 기다리는 현상

## OS suppored SW Solution
  - ## Spinlock
    - ### ⭐ 정수 변수
    - ### ⭐ 초기화, P(), V() 연산으로만 접근 가능하다
      - ### ✔ 위 연산들은 Indivisible (분리되지 않는) or Atomic 연산 
      - ### ✔ OS가 보장한다
      - ### ✔ 전체가 하나의 Instruction cycle 에 수행된다 ➡️ Preemption 되지 않는다
      - <img src="https://user-images.githubusercontent.com/35948339/128887678-e76ddfc9-fe1f-48ed-a0bb-1486b18069b5.png" width=600>
      - ### P(S) ➡️ 물건을 꺼내 가는 것, 자물쇠를 건다
      - ### V(S) ➡️ 물건을 반납 하는 것, 자물쇠를 푼다
      - <img src="https://user-images.githubusercontent.com/35948339/128888172-a6bc877a-c7e7-4016-b94b-ea0c98e9178f.png" width=600>
      - ### ⭐ active = 1 (임계 지역에 프로세스가 없음) <br><br> 1️⃣ P(S) (자물쇠를 걸고 들어간다) <br><br> 2️⃣ active를 0으로 바꾼다 <br><br> 3️⃣ ❓ 다른 프로세스가 들어오면, active = 0을 보고 진입불가 ❌ <br><br> 4️⃣ 작업을 마치고, V(S) 자물쇠 풀기, active를 0으로 바꾸기
  - ## Spinlock의 문제점
    - ### 🟥 멀티 프로세서 시스템에서만 사용 가능 ‼
      - ### 🚦 프로세서가 1 개라면 <br><br> ️1️⃣ P1이 active를 0으로 만들고 임계 영역 진입 <br><br> 2️⃣ 임계 영역에서 작업 중 🟥 Preemption (P(S), V(S) 작업이 아니므로 Preemption이 가능하다) <br><br> 3️⃣ P2는 CPU 할당 받고, `P(S) { while(S <= 0) }` ▶️ 계속 대기중 <br><br> 4️⃣ P1, P2 모두 작업을 못한다
      - ### 🟥 Busy Waiting ‼ 
      - ### ⭐ 프로세스가 각각 CPU를 할당 받아서 동시에 실행 되어야만 성립 ‼
  - ## Semaphore

## Languague-Level Solution
