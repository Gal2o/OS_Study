# Mutual Exclusion Solutions

## SW Solution
  - ## Dekker's Algorithm
    - <img src="https://user-images.githubusercontent.com/35948339/128881092-ece613f2-5dff-4eb3-ad6c-8242fd40cd66.png" width=600>
    - ### 두 개의 프로세스 ME를 보장하는 최초의 알고리즘
    - ### Version 1, 2, 3 보완한 방법
  - ## Peterson's Algorithm
    - <img src="https://user-images.githubusercontent.com/35948339/128881517-b6cd3810-650c-4ddc-b655-9286810b8a38.png" width=600>
    - ### Dekker's Algorithm 보다 간단하게 구현
  - ## Dijkstra's Algorithm
    - ### ⭐ 최초로 프로세스 N개의 ME 해결
    - ### ⭐ 실행 시간이 가장 짧은 프로세스에 CPU를 할당하는 Semaphore 방법 <br><br> ⭐ 가장 짧은 평균 대기시간 제공
    - <img src="https://user-images.githubusercontent.com/35948339/128883255-ba3a87ac-e3d7-484d-aced-9e078d982592.png" width=600>
    - ### ⭐ Dijkstra에서의 flag[]
      - ### ✔ idle : 프로세스가 임계 지역 진입을 시도하고 있지 않을 때
      - ### ✔ want-in : 프로세스의 임계 지역 진입 시도 1단계
      - ### ✔ in-CS : 프로세스의 임계 지역 진입 시도 2단계
        - ### ⭐ in-CS 안에 나 혼자 있으면 임계 영역에 들어가겠다 <br><br> ‼ 만약에 누군가 있었으면, 처음으로 다시 돌아간다
  - ## SW solution 들의 문제점
    - ### 🟥 Dijkstra Solution 처럼 빙빙 도는 현상이 목격 된다
    - ### 🟥 ➡️ 속도가 느리다
    - ### 🟥 구현이 복잡하다
    - ### ‼ ME primitive 실행 중 선점 될 가능성이 있다 ➡️ Interrupt 조절 ➡️ Overhead 발생 ‼
    - ### 🟥 Busy Waiting 발생 ➡️ 자기 차례 올 때까지, 빙빙 돌면서 기다리는 현상

## OS suppored SW Solution
  - ## Spinlock
    - ### ⭐ 정수 변수
    - ### ⭐ 초기화, P(), V() 연산으로만 접근 가능하다
      - ### ✔ 위 연산들은 Indivisible (분리되지 않는) or Atomic 연산 
      - ### ✔ OS가 보장한다
      - ### ✔ 전체가 하나의 Instruction cycle 에 수행된다 ➡️ Preemption 되지 않는다
      - <img src="https://user-images.githubusercontent.com/35948339/128887678-e76ddfc9-fe1f-48ed-a0bb-1486b18069b5.png" width=600>
      - ### P(S) ➡️ 물건을 꺼내 가는 것, 자물쇠를 건다
      - ### V(S) ➡️ 물건을 반납 하는 것, 자물쇠를 푼다
      - <img src="https://user-images.githubusercontent.com/35948339/128888172-a6bc877a-c7e7-4016-b94b-ea0c98e9178f.png" width=600>
      - ### ⭐ active = 1 (임계 지역에 프로세스가 없음) <br><br> 1️⃣ P(S) (자물쇠를 걸고 들어간다) <br><br> 2️⃣ active를 0으로 바꾼다 <br><br> 3️⃣ ❓ 다른 프로세스가 들어오면, active = 0을 보고 진입불가 ❌ <br><br> 4️⃣ 작업을 마치고, V(S) 자물쇠 풀기, active를 0으로 바꾸기
  - ## Spinlock의 문제점
    - ### 🟥 멀티 프로세서 시스템에서만 사용 가능 ‼
      - ### 🚦 프로세서가 1 개라면 <br><br> ️1️⃣ P1이 active를 0으로 만들고 임계 영역 진입 <br><br> 2️⃣ 임계 영역에서 작업 중 🟥 Preemption (P(S), V(S) 작업이 아니므로 Preemption이 가능하다) <br><br> 3️⃣ P2는 CPU 할당 받고, `P(S) { while(S <= 0) }` ▶️ 계속 대기중 <br><br> 4️⃣ P1, P2 모두 작업을 못한다
      - ### 🟥 Busy Waiting ‼ 
      - ### ⭐ 프로세스가 각각 CPU를 할당 받아서 동시에 실행 되어야만 성립 ‼
  - ## Semaphore (‼ Spinlock과 무엇이 다른지 비교)
    - ### ⭐ Dijkstra가 제안
    - ### ⭐ Busy Waiting 문제 해결
    - ### ⭐ 음이 아닌 정수형 변수 (S), 초기화 연산, P(), V()
    - ### ✔ OS가 보장한다
    - ### ✔ 전체가 하나의 Instruction cycle 에 수행된다 ➡️ Preemption 되지 않는다
      - #### 🤷‍♂️ P: Probern (검사), V: Verhogen (증가)
      - #### 🤷‍♂️ 초기화 연산: S 변수에 초기 값 부여
      - <img src="https://user-images.githubusercontent.com/35948339/129046737-b3a4a391-7f46-4233-91f4-2fa258d9598f.png" width=600>
      - #### 🤷‍♂️ P() 연산 <br><br> 1️⃣ `S > 0` (들어갈 수 있으면) ▶️ `S ⬅️ S-1` (자물쇠를 잠근다) <br><br> 2️⃣ `S < 0` (들어갈 수 없으면) ‼ Spinlock처럼 Busy Waiting이 아닌 ready-queue에 가만히 대기 하고 있는다 ‼
      - #### 🤷‍♂️ V() 연산 <br><br> 1️⃣ ready-queue에 기다리고 있는 프로세스 중 하나를 깨운다 <br><br> 2️⃣ `S ⬅️ S+1` 자물쇠를 열고 나간다
    - ### ⭐⭐ 임의의 S 변수 하나에 Ready-Queue 하나가 할당 된다 ⭐⭐
    - ## ⭐ Semaphore로 해결 가능한 동기화 문제들
      - ### 🤷‍♂️ Mutual Exclusion
        - <img src="https://user-images.githubusercontent.com/35948339/129050582-96f214fe-5aa8-4bde-b11d-c629f450ae03.png" width=600>
      - ### 🤷‍♂️ Process Synchronization
        - ### ✔ 프로세스들의 실행 순서 맞추기
        - ### ❗ 프로세스들은 병행적이고, 비동기적으로 수행
        - <img src="https://user-images.githubusercontent.com/35948339/129051576-7cca05e8-dff9-408e-8598-394d6e449c6a.png" width=700>
        - #### 둘 중 하나가 작업 중이라면, L 지점에 도착해서 자원 반납 ➡️ 다음 프로세스가 작업
      - ### 🤷‍♂️ Producer-Consumer
        - ### ✔ Producer 프로세스 ▶️ 메시지 생성 그룹
        - ### ✔ Consumer 프로세스 ▶️ 메시지를 받는 프로세스 그룹
        - ### 🟢 단일 버퍼를 가진 Producer-Consumer
          - <img src="https://user-images.githubusercontent.com/35948339/129057075-1a809fb9-ac57-4d28-8250-4dd570ec4996.png" width=600>
          - ### ✔ Producer가 메시지를 보낼 때는 Consumer가 접근 못하고 <br><br> Consumer가 메시지를 받을 때 Producer는 메시지를 보낼 수 없다
          - ### ✔ `P(consumed), (produced)` ➡️ Consumer, Producer가 작업 중? <br><br> ✔ `C(produced), (consumed)` ➡️ Producer, 가 작업 시작 ❗
        - ### 🟢 N개의 버퍼를 가진 Producer-Consumer
          - <img src="https://user-images.githubusercontent.com/35948339/129058298-628107e6-4d1b-449d-897d-7401ddaa96b5.png" width=600>
          - ### ✔ Producer, Consumer 프로세스가 여러 개
      - ### 🤷‍♂️ Reader-Writer
      - ### 🤷‍♂️ Dining Philosopher (철학자들의 저녁식사)
    - ## 🔵 Binary Semaphor
      - ### S 가 0 또는 1 두 값만 갖는 경우
      - ### ✔ 상호배제나 프로세스 동기화 목적으로 사용한다
    - ## 🟢 Counting Semaphore
      - ### S 가 0 이상의 정수 값을 갖는 경우
      - ### Producer-Consumer 문제 등을 해결 하기 위해 사용

## Languague-Level Solution
