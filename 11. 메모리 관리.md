# 메모리 관리 (⚙주기억장치 관리)
  - ### <img src="https://user-images.githubusercontent.com/35948339/130362751-3e605809-d991-4146-b434-6ad5dacd7675.png" width=600> <br><br> CPU가 관리 ▶️ 레지스터, 캐시 <br><br> OS가 관리 ▶️ 메인 메모리, 보조기억장치
------
  - ## 메모리 계층구조
    - <img src="https://user-images.githubusercontent.com/35948339/130362873-bf68d22c-57ea-4e69-8ce2-26f1b2553295.png" width=600>
    - ### Block
      - ### 보조기억장치 🔄 주기억장치 사이의 데이터 전송 단위
      - ### 💾Size : 1 ~ 4KB
    - ### Word
      - ### 주기억장치 🔄 레지스터 사이의 데이터 전송 단위
      - ### 💾Size : 16 ~ 64 Bits <br><br> ⭐OS가 32bit, 64bit ▶️ Word 단위의 차이다⭐ <br><br> ▶️ 레지스터 하나의 크기가 32bit/64bit 이고, 메모리에서 Word 단위로 읽어온다
  - ## Address Binding
    - ### `프로그램의 💾논리 주소를` 🔀 실제 메모리의 ⚙물리 주소로 매핑하는 작업
    - <img src="https://user-images.githubusercontent.com/35948339/130363155-481e5b6e-4e66-46e6-93cd-05c836046de4.png" width=800>
    - ### 🔸 코드를 실행시키는 과정
      - ### 1️⃣ 🔹Compile time binding ▶️ Compile Time의 과정
        - ### 프로세스가 메모리에 적재될 위치를 컴파일러가 알게 되는 과정
        - ### 프로그램 전체가 메모리에 올라가야 함
      - ### 2️⃣ 🔹Load time binding ▶️ Load Time의 과정
        - ### 메모리 적재 위치를 컴파일 시점에서 모르면, 대체 가능한 상대 주소를 생성
        - ### 적재 시점 (Load Time)에 시작 주소를 반영하여 사용자 코드 상의 주소를 재설정
        - ### 프로그램 전체가 메모리에 올라가야 함
      - ### 3️⃣ 🔹Run time binding ▶️ 
