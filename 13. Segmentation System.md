# 🔸 Segmentation System (Non-Continuous allocation)
  - <img src="https://user-images.githubusercontent.com/35948339/131689824-59c230f6-610d-4805-bbd3-c87a0a3e97af.png" width=700>
  - ## 🔹 프로그램을 논리적 block으로 분할 (segment)
    - ### Block의 크기가 서로 다르다 <br><br> Ex. stack, heap, main procedure, shared lib, Etc.
  - ## ↔ ‼ Paging System은 같은 크기의 page frame으로 비연속적인 할당으로 사용했었다
  - ## 🔹 [특징](특징)
    - ### ✔ 메모리를 미리 분할 하지 않는다 (Variable Partition Multi-programming 과 유사)
    - ### ✔ Segment sharing / protection 이 편하지만, <br><br> 🟥 그만큼 메모리 관리의 `Overhead`가 크다
    - ### ⭐ `내부 단편화`가 발생하지 않는다 <br><br> ❌ `외부 단편화`가 발생할 수 있다.
------
  - ## 🔸 Address Mapping
    - ### 🔹 Virtual address : ```v = (s,d)```
      - ### s : segment number
      - ### d : offset
    - ### 🔹 Segment Map Table (SMT)
    - <img src="https://user-images.githubusercontent.com/35948339/131690992-fa5786da-939e-4ea1-b372-6e784b129fe7.png" width=700>
    - ### 1️⃣ `Segment length` : 각자 segment 마다 길이가 다르므로 적어놔야 한다 <br><br> 2️⃣ `protection bits`가 추가 되었다
    - ## 🔸 Direct Mapping <br><br> <img src="https://user-images.githubusercontent.com/35948339/131692410-bd5b4ce3-f791-40c3-bdcc-0bdc5d3074a2.png" width=700>
    - ### ⭕ Paging System과 유사하게 실제 주소를 찾아가면 된다
    - ### 1️⃣ 프로세스의 SMT가 저장되어 있는 주소 b에 접근
    - ### 2️⃣ SMT에서 segment s의 entry 찾음 <br><br> s의 entry 위치 = ```b + s*entrySize```
    - ### 3️⃣ 찾아진 entry에 대해 다음 단계들을 순차적으로 실행
      - ### ❌ residence bit가 0인 경우 ➡ swap device로 부터 segment 메모리에 적재 ➡ SMT 갱신 
      - ### ❌ offset d가 segment 길이보다 큰 경우 (d > l) ➡ ⚠ `segment overflow` exception 호출 
      - ### ❌ 허가 되지 않은 연산일 경우 (protection bit) ➡ ⚠ `segment protection` exception 호출
    - ### 4️⃣ 실제 주소 r 계산 ```r = a+d```
    - ### 5️⃣ r 주소의 메모리 접근 성공
    - -----
    - ## 🔸 Memory management 
      - <img src="https://user-images.githubusercontent.com/35948339/131694674-b63554a6-c37e-4d97-9394-14e0f1d9f67b.png" width=600>
      - ### ✔ Variable Partition Multi-programming과 유사
        - ### Segment 적재 시, 크기에 맞추어 분할 후 적재
    - -----
    - ## 🔸 Segment sharing & protection
      - <img src="https://user-images.githubusercontent.com/35948339/131695079-ff2137ec-a8bb-40d6-8582-d3bf39e3d087.png" width=600>
      - ### ✔ 논리적으로 분할되어 있어, 공유 및 보호가 용이하다
      - <img src="https://user-images.githubusercontent.com/35948339/131696836-b5ef2ccc-8ff0-4581-9a90-92d0a0ecb30e.png" height=200>
      - ### ✔ 공유를 할 때도, 논리적으로 나눠 놨기 때문에, 어떤 주소에서도 올바르게 jump를 한다
    - ## 🔸 [Segment Syatem 결론](특징)
     
