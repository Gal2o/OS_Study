## 다중 프로그래밍 시스템
  - ### 여러 개의 프로세스들이 존재
  - ### ✔ 프로세스들은 서로 독립적으로 동작한다
  - ### ✔ 공유 자원 또는 데이터가 있을 때, 문제 발생 가능성이 있다
  - ### ex. 🎨 A와 B가 같은 그림판에 그림을 그린다고 할 때, <br> A가 그림을 그리고 있을 때, B가 같이 그리면, A는 예상하지 못하는 결과를 얻을 수 없다
-----
# Synchronization (동기화)
  - ### ✔ 프로세스 들이 서로 동작을 맞추는 것 또는 서로 정보를 공유 하는 것
-----  
# Asynchronous and Concurrent
  - ### ✔ Asynchronous (비동기적)
    - ### ✔ 프로세스 들이 서로에 대해 모른다
  - ### ✔ Concurrent (병행적)
    - ### 여러 개의 프로세스들이 동시에 시스템에 존재한다.
  - ### ❗ 병행 수행중인 비동기 프로세스들이 공유 자원에 동시 접근 할 때, 문제가 발생 할 수 있다 ❗
-----
- # ✔ Shared Data or Critical Data (공유 데이터)
  - ### 여러 프로세스들이 공유하는 데이터
-----
- # ✔ Critical Section (임계 영역)
  - ### 공유 데이터를 접근하는 코드 영역
  - <img src="https://user-images.githubusercontent.com/35948339/128025809-476fcfb5-69c7-49bc-9fe3-dd757838e821.png" width=600>
  - ### ❗ 기계어 명령의 특성
    - ### Atomicity (원자성) & Indivisible(분리 불가능) ▶️ 명령어는 한번 수행하면 끝까지 수행한다
    - ### 한 기계어 명령의 실행 도중에 Interrupt를 받지 않음
    - ### 🤷‍♂️ 예상 sdata 값은 2일 것이다
  - <img src="https://user-images.githubusercontent.com/35948339/128026901-26f54a3e-8850-4f4e-9675-a31d30aed8e7.png" width=600>
  - ### ❗ 예외 발생 ❗ 기계어 명령어 특성에 의해 ①, ②, ③ / ⓐ, ⓑ, ⓒ 이 실행 될 때는, 방해 받지 않는다
  - ### ❗ 하지만 명령어 사이에는 Preemption이 발생 할 수 있다
  - ### ⭐ 예상한 결과가 다르게 나올 수 있다 ▶️ ❗ Race Condition 발생
-----
- # ✔ Mutual Exclusion (상호 배제)
  - <img src="https://user-images.githubusercontent.com/35948339/128028179-4b7ff892-8096-4c34-833e-07c6c18ddc45.png" width=350 height=350>
  - ### ✔ Race Condition을 발생시키지 않고 원하는 결과를 얻기 위해,
  - ### 둘 이상의 프로세스가 ⭐동시에⭐ Critical Section에 진입하는 것을 막는 것
- ## 🔵 Mutual Exclusion의 기본연산
    - ### enterCS()
      - ### 🚦 Critical Section 진입 전 검사
      - ### 다른 프로세스가 Critical Section 안에 있는지 검사
    - ### exitCS()
      - Critical Section에서 나갈 때, 나간다는 것을 시스템이 알림 ⏰
- ## ⭐Mutual Exclusion 기본연산의 선행조건⭐
  - ## 1️⃣ Mutual Exclusion
    - ### Critical Section(CS) 에 프로세스가 있으면, 다른 프로세스의 진입 금지
  - ## ️2️⃣ Progress (진행)
    - ### ❌ CS 안에 있는 프로세스 외에는, 다른 프로세스가 CS에 진입하는 것을 방해 하면 안된다 ❌
    - ### ❌ CS가 비어 있는데, 프로세스 A가 CS에 진입 하는 것을 프로세스 B가 가로막는 행위는 금지 ❌
    - ### ❌ 한 프로세스가 두번 연속 CS에 진입 할 수 없다 ❌
  - ## 3️⃣ Bounded Waiting (한정대기)
    - ### 프로세스의 CS 진입은 정해진 시간 내에 진입 해야 한다
-----
- ## 두 개의 프로세스 Mutual Exclusion 예시
  - ## Version 1
    - <img src="https://user-images.githubusercontent.com/35948339/128036278-6849f509-5898-4c79-8037-d23b3d1d7eb2.png" width=700>
    - #### 1️⃣ turn 객체로 프로세스 순서를 정한다
    - #### 2️⃣ 자신의 턴이 아니면, 기다리다가 들어가서 작업을 마치고 turn을 바꿔준다
    - #### ‼ P0의 차례일 때, P0이 죽었다 ▶️ P1도 영원히 들어갈 수 없다 ❌
    - #### ‼ P0이 CS에 접근해서 작업을 마치고, P1의 진입 차례 일 때, <br> P1이 CS진입 하기 전에 P0가 더 빠르게 CS에 도착한다해도 CS에 진입 할 수 없다 ❌
    - ### ‼ Progress 조건 위배 ‼
  - ## Version 2
    - <img src="https://user-images.githubusercontent.com/35948339/128037491-ac9abd1f-68c2-4401-80e3-2e14cc29471f.png" width=700>
    - #### 1️⃣ 기다리다가 들어갈 차례면 flag = 1로 변경하고 CS 진입
    - #### 2️⃣ CS에 진입해서 작업을 끝내면, 자신의 flag = 0 으로 바꾸고 끝내자
    - ### ‼ P0이 CS에 진입할 차례에, flag를 변경하기 전, Preemption <br> ▶️ P1이 flag[0] = false를 확인하고 CS 진입, 작업 시작 <br> ▶️ P0이 다시 자원을 할당 받아서 flag[0]=true, CS 진입
    - ### ‼ Mutual Exclution 위배 ‼
  - ## Version 3
    - <img src="https://user-images.githubusercontent.com/35948339/128038926-7d88e69a-914b-4dc8-987d-8b627abb52b2.png" width=700>
    - #### 1️⃣ 먼저 flag를 바꾸고, 다른 프로세스의 flag가 false라면 CS에 진입한다
    - #### 2️⃣ 작업을 끝내고, 자신의 flag를 false로 변경한다
    - ### ‼ P0이 flag를 변경하고 Preemption <br> ▶️ P1이 flag를 변경했는데, flag[0]을 보고 대기 <br> ▶️ P0이 다시 자원을 할당 받아서 flag[1] 보고 대기
    - ### ‼ Progress, Bounded Waiting 조건 위배 ‼
------
