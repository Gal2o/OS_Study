# 운영체제의 역할
  - __User Interface (편리성)__
    - CUI (Character User Interface)
    - GUI (Graphical User Interface)
    - EUCI (End-User Comfortable Interface) - Ex. MP3, 임베디드 SW 등..

  - Resource Management (효율성)
    - HW resource (processor, memory, I/O devices, etc)
    - SW resource (file, application, message, signal, etc)

  - Process and Thread management
  - System management (시스템 보호)

## 컴퓨터 시스템의 구성
  - <img src= "https://user-images.githubusercontent.com/35948339/126968453-d8d79acc-3d5e-4bb3-a4e9-6e1a354fac30.png" weight=600 height=600>

# 운영체제의 구분
  - ### 동시 사용자 수
    - ##### Single-user system (단일 사용자)
      - 한 명의 사용자만 시스템을 사용 가능하다
        - 한 명의 사용자가 모든 시스템 자원을 독점한다
        - 자원관리 및 시스템 보호 방식이 간단하다
      - 개인용 장비 (PC, mobile)
        - Windows 10, android, IOS 등
    - ##### Multi-user system
      - 동시에 여러 사용자들이 시스템을 사용한다
        - 각종 시스템 자원(파일 등)에 대한 소유 권한 관리가 필요하다
        - 기본적으로 Multi-tasking 기능이 필요하다
        - OS의 기능 및 구조가 복잡하다
      - 서버, 클러스터 장비 등에 사용
        - UNIX, Linux, Windows server 등
  - ### 동시 실행 프로세스 수
    - ##### Single-tasking system
      - 시스템 내에 하나의 작업(프로세스)만 존재한다
        - 하나의 프로그램 실행을 마친 뒤에 다른 프로그램을 실행한다
      - 운영체제의 구조가 간단하다
      - Ex) MS-DOS
    - ##### Multi-tasking system (Multi-Programming-system)
      - 동시에 여러 작업(프로세스)의 수행가능
        - 작업들 사이의 동시 수행, 동기화, 스케쥴링 등을 관리해야 한다
      - 운영체제의 기능 및 구조가 복잡하다
      - Ex) Unix/Linux, Windows 등
  - ### 작업 수행 방식
    - ### 순차 처리
      - ##### 운영체제 개념이 존재하지 않음
        - 사용자가 기계어로 직접 프로그램 작성
        - 컴퓨터에 필요한 모든 작업 프로그램에 포함
          - 프로세서에는 명령어 저장 방법, 계산 대상, 결과 저장 위치 등
        - ❗ 실행하는 작업 별 순차 처리
          - ❗ __각각의 작업에 대한 준비 시간이 소요된다__
          - ❗ 언어 별로 환경을 세팅해야 하는 시간 등이 소요되었다
          - Ex) 천공카드
    - ### Batch System
      - ##### 모든 시스템을 중앙(전자계산소 등)에서 관리 및 운영
        - ❗ 사용자의 요청 작업(천공카드 등)을 환경 별로 일정시간 모아두었다가 100개가 쌓이면 한꺼번에 실행하는 방식으로 운영
      - ##### 시스템 지향적
        - ❗ 장점
          - 많은 사용자가 시스템 자원 공유
          - 처리 효율 향상
        - ❌ 단점
          - 생산성 저하 (같은 환경의 작업들이 모이기를 기다려야 함)
          - 긴 응답시간
            - 약 6시간을 기다려야 결과를 알 수 있었다.
    - ### Time Sharing Systems
      - ##### 여러 사용자가 자원을 동시에 사용
        - 💾 OS가 파일 시스템 및 가상 메모리 관리
      - ##### 사용자 지향적
        - <img src ="https://user-images.githubusercontent.com/35948339/126971782-d5092c1f-c402-4346-869c-d611c1601031.png" width=500 height=300>
        - 대화형 시스템
        - 단말기 사용 (CRT terminal)
        - ❗ 장점
          - 응답시간 단축 (약 5초)
          - 생산성 향상
        - ❌ 단점
          - 통신 비용 증가
          - 사용자가 많아져서 시스템 부하로 인한 속도 감소
    - ### 🖥️ Personal Computing
      - ##### 개인이 시스템 전체 독점
      - ##### OS가 상대적으로 단순함
      - ❗ 장점
        - 빠른 응답시간
      - ❌ 단점
        - 성능이 낮음 (CPU가 한 개)
    - ### 💻 Parallel Processing System
      - ##### 단일 시스템 내에서 둘 이상의 프로세서 사용
      - ##### 메모리 등의 자원 공유 (Tightly-coupled system)
      - ##### 사용 목적
        - ⭐ 성능 향상
        - ⭐ 신뢰성 향상 (CPU 한 개가 고장나도 나머지가 정상 작동 중)
      - ❗ 프로세서 간 관계 및 역할 관리 필요
    - ### Distributed Processing Systems
      - <img src ="https://user-images.githubusercontent.com/35948339/126972780-4423e2a2-4894-4cbe-862e-36b5ef8b9f23.png" witdh=500 height=300>
      - ### 네트워크를 기반으로 구축된 병렬처리 시스템
        - 물리적인 분산, 통신망으로 상호 연결
        - 사용자는 __`분산 운영체제`__ 를 통해 하나의 프로그램, 자원처럼 사용 가능 (은폐성, transparency)
        - Ex) Cluster, client-server-system
      - ❗ 장점
        - ⭐ 자원 공유를 통한 높은 성능
      - ❌ 단점
        - 🌨️ 구축 및 관리가 어렵다
    - ### Real-time Syatems
      - #### 작업 처리에 제한 시간(deadline)을 갖는 시스템
        - ❗ 제한 시간 내에 서비스를 제공하는 것이 자원 활용 효율보다 중요하다
      - #### 작업의 종류
        - Hard real-time
          - 시간 제약을 지키지 못하는 경우 시스템에 치명적인 영향
            - Ex) 발전소 제어, 무기 제어
        - Soft real-time
          - Ex) 동영상 제생
        - Non real-time
# 운영체제의 구조
  - ### Kernel
    - ### OS의 핵심 부분 ❗ (메모리에 항상 상주중)
      - 가장 빈번하게 사용되는 기능들 담당
        - 시스템 관리(processor, memory, etc)
  - ### 유틸리티
    - 메모리에 항상 올라가 있지 않음
    - UI 등 서비스 프로그램
  
  - ## 단일 구조
    - <img src= "https://user-images.githubusercontent.com/35948339/126976683-e628d87d-277d-4044-ad29-1998265dfac6.png" width=600>
    - ❗ 장점
      - 커널 내 모듈 간 직접 통신
      - 효율적인 자원 관리 및 사용
    - ❌ 단점
      - 커널의 거대화
        - 오류 및 버그, 추가 기능 구현 등 유지보수가 어렵다
        - 동일 메모리에 모든 기능이 있어, 문제가 생기면 시스템 전체에 영향이 미친다
  - ## 계층 구조
    - <img src= "https://user-images.githubusercontent.com/35948339/126977739-3d9a7baa-5d7e-44ed-a58b-0fc58c5590f8.png" width=500 height=300>
    - ❗ 장점
      - 모듈화
        - 계층간 검증 및 수정이 용이하다
      - 설계 및 구현의 단순화
    - ❌ 단점
      - 단일 구조 대비 성능이 저하됨
        - 원하는 기능 수행을 위해서 여러 계층을 거쳐야 한다
  - ## 마이크로 커널 구조
    - <img src ="https://user-images.githubusercontent.com/35948339/126978045-2bb0145e-5a63-4fbf-9064-a5ccf13f9690.png" width=500 height=300>
    - ### 커널의 크기 최소화
      - ❗ 필수 기능만 포함
      - ❗ 기타 기능은 사용자 영역에서 수행   
