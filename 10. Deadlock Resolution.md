# Deadlock

## Deadlock의 개념
  - ### Blocked/asleep state
    - ### 프로세스가 특정 이벤트, 필요한 자원을 기다리는 상태
    
  - ### ⭐Deadlock state⭐
    - ### ✔ 프로세스가 발생 가능성이 없는 이벤트를 기다리는 경우
    - ### ✔ 시스템 내에 Deadlock에 빠진 프로세스가 있는 경우
    
  - ### Deadlock vs Starvation
    - <img src="https://user-images.githubusercontent.com/35948339/129749917-20166bfb-d608-48f4-8de6-708d933fc962.png" width=600>
    - ### ✔ Deadlock ▶️ asleep 상태에서 자원을 기다리는데 절대 다시 받을 일이 없다
    - ### 🚦 Starvation ▶️ ready 상태에서 프로세스 할당을 기다리는데 자기 차례가 안오는 것 뿐
-----
## 자원의 분류
  - ### 선점 가능 여부에 따른 분류
    - ### 🔹 Preemptible 자원
      - ### 🔹 선점 당한 후, 다시 자원을 할당 받았을 때, 문제가 없는 자원
      - ### 🎁 Processer ▶️ ⭐Context Switching <br><br> Memory ▶️ ⭐Swap-device 덕분에 다시 돌려받았을 때, 문제가 없다
    - Non-preemptible 자원
      - ### 🔸 선점 당하면, 이후 진행에 문제가 발생하는 자원 <br><br> Ex. 덮어쓰기 등 ▶️ Rollback, restart등 특별한 동작이 필요하다
      - ### 🎁 Disk drive 등
  - ### 할당 단위에 따른 분류
    - ### Total allocation
      - ### 🔹 자원 전체를 프로세스에게 할당
      - ### 🎁 Ex. Processor, Disk drive 등
    - ### Partitioned allocation
      - ### 🔹 하나의 자원을 여러 조각으로 나누어, 여러 프로세스 들에게 할당
      - ### 🎁 Ex. Memory
  - ### 동시 사용 가능 여부에 따른 분류
    - ### Exclusive allocation
      - ### 🔹 한번에 한 프로세스만 사용 가능한 자원
      - ### 🎁 Ex. Processor, Disk drive, <br><br> ⭐ Memory ▶️ 여러 프로세스에게 할당된 공간들은 해당 프로세스 혼자 쓰므로, Exclusive ‼
    - ### Shared allocation
      - <img src="https://user-images.githubusercontent.com/35948339/129754404-0caba583-5c5b-4917-86fb-1039a19d368c.png" width=400>
      - ### 🔹 여러 프로세스가 동시에 사용 가능한 자원
      - ### 🎁 Ex. Program(Source code), Shared data
  - ### 재사용 가능 여부에 따른 분류
    - ### SR (Serially-reusable)
      - ### 🔹 시스템 내에 항상 존재하는 자원
      - ### 🔹 사용이 끝나면, 다른 프로세스가 사용 가능
      - ### 🎁 Ex. Processor, Memory, Disk drive, Program 등
    - ### CR (Consumable)
      - ### 🔹 한 프로세스가 사용하면, 사라지는 자원
      - ### 🎁 Ex. Signal, Message 등
------
## ⭐ Deadlock을 발생 시킬 수 있는 자원의 형태 ⭐
  - ### ⭐ Non-preemptible 자원
  - ### ⭐ Exclusive allocation
  - ### ⭐ SR (Serially-reusable)
-----
## Deadlock Model
  - ### 🔹 Graph Model
    - ### Node
      - 프로세스 노드(P1, P2), 자원 노드(R1, R2)
    - ### Edge (⭐ 순서 중요)
      - <img src="https://user-images.githubusercontent.com/35948339/129915958-1ff24f37-cb85-41ad-8f32-87153061f5b4.png" width=400>
      - ### `💎Rj ▶️ 💾Pi` : 자원 Rj이 프로세스 Pi에 할당 되었다.
      - ### `💾Pi ▶️ 💎Rj` : 프로세스 Pi가 자원 Rj를 요청 (대기 중)
  - ### 🔹 State Transition Model
    - <img src="https://user-images.githubusercontent.com/35948339/129917691-2015f126-ea92-4628-a67d-db4bbcddbb77.png" width=600>
    - ### `S33 Deadlock!`
    - ### 2개의 프로세스와 A type의 자원 (unit) 2개 존재
    - ### 프로세스는 한번에 자원 `하나` 만 요청/반납 가능
------
## ⭐⭐ Deadlock 발생 필요 조건 ⭐⭐
  - ## 💾 자원의 특성
    - ### `⭐Exclusive use of resources⭐`
    - ### `⭐Non-preemptible resources⭐`
  - ## 💎 프로세스의 특성
    - ### `⭐Hold and wait (Partial allocation)⭐`
      - ### 🔹 자원을 하나 할당받으면서, 다른 자원 요청
    - ### `⭐Circular wait⭐`
-----
## Deadlock 해결 방법
  - ### 🔸 Deadlock Prevention
    - ### ‼ 절대 Deadlock을 만들지 않겠다 ‼
    - ### 🟥 4개의 deadlock 발생 필요 조건 중 하나를 제거
      - ### 🟥 Exclusive use of resources 제거
        - ### 🔹 모든 자원을 공유 허용 ▶️ 현실적으로 불가능 ❌
      - ### 🟥 Non-preemptible resources 제거
        - ### 🔹 모든 자원에 대해 선점 허용 ▶️ 현실적으로 불가능 ❌
        - ### 유사한 방법 <br><br> ♻ 프로세스가 할당 받을 수 없는 자원을 요청한 경우 <br><br> 기존에 가지고 있던 자원을 모두 반납하고 작업 중단 ❌ <br><br> 이후 처음 또는 save-point 부터 다시 시작 <br><br> ▶️ 심각한 오버헤드 발생 ❌
      - ### 🟥 Hold and wait (Partial allocation) 제거
        - ### 🔹 한 프로세스의 필요 자원을 한번에 모두 할당
        - ### ❌ 자원 낭비 발생 ❌ ▶️ 다른 프로세스가 필요한 자원을 계속 가지고 있음
        - ### 🔹 무한 대기 현상 발생 가능
      - ### 🟥 Circular wait 제거
        - ### 🔹 자원들에게 순서를 부여
        - <img src="https://user-images.githubusercontent.com/35948339/129922554-72bff542-ba13-46e1-8a06-847055c1ec7b.png" width=400>
        - ### 🔹 프로세스는 순서의 증가 방향으로만 자원 요청 가능 <br><br> 🔹 사이클이 발생하지 않는다 <br><br> ‼ 하지만 P2가 R1 R3 하나만 있어도 작업이 가능하다고 가정 했을 때, <br><br> 🟥 R3이 남아있어도 증가 방향으로만 요청이 가능하므로 <br><br> 🟥 R1을 받을 수 없어서 R3도 받을 수가 없다 <br><br> ▶️ ❌ 자원 낭비 발생 ❌
    - ### ‼‼ `결론 ▶️ 심각한 자원 낭비, 비현실적`

