# FCFS (First-Come-First-Service)
  - ### Non-Preemptive Scheduling (비선점)
    - ### Scheduling 기준
      - ### ✔ 도착 시간 (누가 먼저 Ready Queue에 도착)
      - ### 먼저 도착한 프로세스를 처리한다
    - ### 자원을 효율적으로 사용 가능
      - ### Scheduling 오버헤드 ⬇️
      - ### CPU가 유휴시간 없이 작업한다
    - ### Batch System에 적합하다, Interactive(대화형) System에는 ❌

    - ### ❌ 단점
      - ### ❗ Convoy Effect
        - ### 먼저 들어온 프로세스가 긴 작업시간을 가진다면, <br> 다른 프로세스들은 대기시간이 길어진다 ❗ (대기시간 >> 실행시간)
      - ### ❗ 긴 평균 응답시간
----
# RR (Round-Robin)
  - ### Preemptive Scheduling (선점)
    - ### Scheduling 기준
      - ### ✔ 도착 시간 (누가 먼저 Ready Queue에 도착)
      - 먼저 도착한 프로세스를 처리한다
    - ### ⭐ 자원 사용에 제한 시간 (Time Quantum)이 있다
      - #### 프로세스는 할당된 시간이 지나면 자원 반납
        - ### Time Quantum이 매우 크다면 ▶️ FCFS
        - ### Time Quantum이 매우 작다면 ▶️ Processor Sharing (❗ 프로세서를 동시에 쓰고 있는 느낌)
          - #### ❗ High Context Switch 오버헤드 발생
    - ### 특정 프로세스의 자원 독점 방지
    - ### ❗ Context Switch 오버헤드가 ⏫
  - ### ⭐ Interactive(대화형), Time-Sharing(시분할) 시스템에 적합하다.
----
# SJF (Shortest-Job-First)
  - ### Non-Preemptive Scheduling (비선점)
    - ### Scheduling 기준
      - ### ✔ 실행 시간 기준
      - ### Burst-Time이 가장 짧은 프로세스 먼저 처리
      - ### ❗ 금방 끝낼 수 있는데, 기다리는 것이 불공평 하다
  - ### 🟢 장점
    - ### ⭐ 평균 대기시간 최소화
    - ### ⭐ 시스템 내 프로세스 수 최소화
      - ### ⭐ 스케줄링 부하 감소, 메모리 절약 ▶️ 시스템 효율 향상
    - ### ⭐ 많은 프로세스들에게 빠른 응답시간 제공
  - ### ❌ 단점
    - ### ❌ Starvation (기아 현상) 발생
      - #### Burst-Time이 긴 프로세스는 자원 할당을 영원히 받을 수 없을지도...
      - #### ❗ Aging으로 해결 가능하다
    - ### ❌ 정확한 실행시간을 알 수 없다
----
# SRTN (Shortest-Remaining-Time-Next)
  - ### ❗ SJF의 변형
  - ### Preemptive Scheduling (선점)
    - ### ✔ 잔여 실행 시간이 더 적은 프로세스가 Ready 상태가 되면 선점된다
  - ### 🟢 장점
    - ### SJF의 장점 극대화
  - ### ❌ 단점
    - ### ❌ 프로세스 생성 시, 총 실행 시간 예측이 필요하다
    - ### ❌ 잔여 실행을 계속 추적해야 한다
      - ### Context Switch 오버헤드 발생
  - ### 구현 및 사용이 비현실적이다
----
# HRRN (High-Response-Ratio-Next)
  - ### ❗ SJF의 변형
  - ### ✔ SJF + Aging
    - ### ✔ Aging ▶️ 프로세스의 대기 시간을 고려하여 자원 할당
  - ### Non-Preemptive Scheduling (비선점)
  - ### Scheduling 기준
    - <img src="https://user-images.githubusercontent.com/35948339/127885373-1d066b2a-6805-4e2c-943c-c75a5951ac64.png">
    - ### 🔵 Response Ratio가 높은 프로세스 우선 (WT = 대기 시간, BT = 실행 시간)
      - ### SJF의 장점 + Starvation 방지
  - ### ❌ 단점
    - ### ❌ 실행 시간 예측 기법 필요 ▶️ Context Switch 오버헤드
  - <img src="https://user-images.githubusercontent.com/35948339/127885945-8aea2bcb-00d2-4bc3-9777-814ef3ec02fd.png" >
  - ### ex. P2: (BT=7 + WT=2) / (BT=7) ▶️ 1.29 >> P3: (BT=2 + WT=0) / (BT=2) ▶️ 1
----
# 중간 정리
  - <img src="https://user-images.githubusercontent.com/35948339/127886814-73dd5c76-474c-4456-8580-2e1d77e0cb97.png" witdh=500 height=500>
  - ### ❌ 시스템의 성능을 높이지만, 문제점이 발생한다
  - ### ✔ 이러한 문제를 해결하는 것이 MLQ, MFQ
----
# MLQ (Multi-Level Queue)
  - <img src="https://user-images.githubusercontent.com/35948339/127888000-2242e499-c087-4df5-adab-01a272e6ae8a.png" witdh=500 height=500>
  - ### ✔ 위의 개념들은 Ready-Queue가 한 개 였지만, MLQ, MFQ는 Ready-Queue가 여러 개
  - ### ⭐ 작업 또는 우선순위 별도의 Ready-Queue를 가진다
    - ### ⭐ 최초 할당된 Queue를 벗어나지 못함
    - ### ⭐ 각각의 Queue는 자신만의 Scheduling 사용
  - ### Queue 사이에는 우선순위 기반의 Scheduling 사용
  - ### 🟢 장점
    - ### 중요한 프로세스는 먼저 처리한다
  - ### ❌ 단점
    - ### ❌ 여러 개의 Queue 관리 등 Scheduling 오버헤드 발생
    - ### ❌ 우선순위가 낮은 Queue는 Starvation 발생 가능성 ⏫
----
# MFQ (Multi-Level-Feedback-Queue
  - <img src="https://user-images.githubusercontent.com/35948339/127888833-495e4705-c099-4cd5-aac1-3bae32baeb77.png" witdh=400 height=400>
  - ### ❌ MLQ 의 최초 할당된 Queue를 벗어나지 못하는 단점을 보완
  - ### ⭐ 프로세스의 Queue간 이동이 허용된 MLQ
  - ### ⭐ Feedback을 통해 우선순위 조정
    - ### ⭐ 현재까지의 프로세서 사용 데이터 활용
  - ### 특징
    - ### 동적인 우선순위 조정
    - ### Preemptive Scheduling
  - ### ✔ 프로세스에 대한 사전 정보 없이 SJF, SRTN, HRRN 기법의 효과를 볼 수 있다
  - ### ❌ 단점
    - ### ❌ 설계 및 구현이 복잡하고, Scheduling 오버헤드가 크다
    - ### ❌ Starvation 문제
  - ### ⭐ 변형 시키는 방법
    - ### ⭐ 각 Ready-Queue마다 시간 할당량을 다르게 배정
    - ### ⭐ I/O-bounded 위주 프로세스들을 상위 우선순위 Queue로 이동
      - ### ❗ I/O-bounded 위주 프로세스들은 실행 시간이 짧으므로, <br> ✔ 시스템 전체 평균 응답 시간을 줄일 수 있다
    - ### ⭐ 대기 시간이 너무 길어진 프로세스들을 상위 우선순위 Queue로 이동 (Aging)
