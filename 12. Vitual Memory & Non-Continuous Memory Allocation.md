# Virtual Storage (Memory)
  - ### 🔹Non-Continuous allocation
  - ### 🔹사용자 프로그램을 여러개의 block으로 분할
  - ### ⭐실행 시, 필요한 block들만 메모리에 적재 <br><br> ⭐나머지 block 들은 swap-device에 존재한다
  - ### ✔Paging System <br> ✔Segmentation System <br> ✔Hybrid Paging / Segmentation System
--------
- ## Non-continuous allocation
  - ### 🔹Virtual address (가상주소) ▶ relative addrress 
    - ### Logical address (논리주소) <br><br> 연속된 메모리 할당을 가정한 주소
  - ### 🔹Real address (실제 주소) ▶ Physical address 
    - ### 실제 메모리에 적재된 주소
  - <img src="https://user-images.githubusercontent.com/35948339/130817083-3b0f2d25-5950-4659-8171-06873620c785.png" width=700>
  - ### ⭐Address Mapping 란? <br><br> ⚙Virtual address ▶ Real address 로 변환 하는 것

- ## 🔸Block Mapping
  - ### 🔹사용자 프로그램을 block 단위로 분할/관리
    - ### 💾각 block에 대한 address mapping 정보를 가지고 있다
  - ### 🔹Virtual address : v = (b,d)
    - <img src="https://user-images.githubusercontent.com/35948339/130818616-c0b1dbba-c802-4f2b-81e4-589645c377a1.png" height=200>
    - ### ✔b = block number
    - ### ✔d = offset in block
  - ### 🔹Block map table
    - ### ✔Address mapping 정보 관리 <br><br> ⭐커널 공간에 ❗프로세스❗ 마다 하나의 BMT를 가진다
    - ### ✔Residence bit : 해당 블록이 메모리에 적재되었는지 여부 ▶ 0/1
    - -----
    - ### <img src="https://user-images.githubusercontent.com/35948339/130819085-8d17f9e1-7b90-49b9-b4d6-357e652109bb.png" width=600> 
    - ### 🔸실제 주소 찾아가는 방식
    - ### 1️⃣ 프로세스의 BMT에 접근 
    - ### 2️⃣ BMT에서 block number으로 위치 찾음 
    - ### 3️⃣ Residence bit 검사 
      - ### 🟥 0인 경우 swap device에서 해당 블록을 메모리로 가져오고 BMT 업데이트 후, 🔵 실행
      - ### 🔵 1인 경우, BMT에서 b에 대한 a 확인 
    - ### 4️⃣ 실제 주소 r = a + d로 메모리 접근

- ## 🔸⭐Paging System
  - <img src="https://user-images.githubusercontent.com/35948339/130822007-9c833e1a-ea61-47eb-8b93-785d01d293b9.png" width=600>
  - ### 🔹프로그램을 같은 크기의 block으로 분할 
  - ### 💾Page 
    - ### 프로그램의 분할된 block
  - ### 🔲Page frame 
    - ### 메모리의 분할 영역
    - ### Page와 같은 크기로 분할
  - ### 🔸특징
    - ### 🔹논리적 분할이 아니다 (Page 크기로 분할) <br> ✔ Page 공유 및 보호 과정이 복잡하다 ↔ ❗ Segmentation과 비교한다면,
    - ### 🔹⭐외부 단편화는 발생하지 않는다 <br><br> ✔ 일정한 크기의 Page frame = Page 크기이기 때문에, 공간이 없으면 적재 ❌ / 남으면 적재 ⭕
    - ### 🟥내부 단편화 발생 가능 <br><br> <img src="https://user-images.githubusercontent.com/35948339/130824189-ba53f5a1-35d1-45c8-953d-0a96fe246465.png" width=300> <br><br> ❗ 프로세스를 일정한 Page 크기로 자르다 보면 마지막에 아주 작은 부분이 남을 수 있기 때문에
  ------
  - ### 🔸Address Mapping
    - ### 🔹Virtual address : v = (p,d)
      - ### p : page number
      - ### d : offset
    - ### 🔹PMT 사용(Page Map Table) <br><br> <img src="https://user-images.githubusercontent.com/35948339/130828051-5ccab041-52b6-49b0-8989-b8b299b7a4c7.png" width=500> <br><br> 🔹 모든 페이지들은 swap device에 저장 되어 있으며, secondary storage address가 그 주소이다
    - -----
    - ### 🔸Direct mapping (직접 매핑)
      - ### 🔹Block mapping과 유사
      - ### 🔹PMT도 마찬가지로 커널 공간에 프로세스마다 갖고 있다
      - <img src="https://user-images.githubusercontent.com/35948339/130828572-277921ff-6df3-4cbd-a20a-0389a2a794b5.png" width=700> 
      - ### 🔸실제 주소 찾아가는 방식 
        - ### 1️⃣ 해당 프로세스의 PMT가 저장되어 있는 b에 접근 
        - ### 2️⃣ 해당 PMT에서 p에 대한 entry = `(b + p*entrySize)` 를 찾는다
        - ### 3️⃣ 찾아진 entry의 Residence bit 검사  
          - ### 🟥 0인 경우 ➡ `⭐page fault⭐` <br><br> swap device (I/O) 에서 해당 page 메모리로 적재 <br><br> 🚧(Running ➡ asleep) Context Switch 발생 ⚠(Overhead가 크다) <br><br> PMT 업데이트 하고, 🔵 실행 <br><br> 
          - ### 🔵 1인 경우, 해당 entry에서 page frame 번호 p' 확인 
        - ### 4️⃣ p'와 offset d를 사용하여 r = `(p'*pageSize + d)` 생성
        - ### 5️⃣ 실제 주소 r로 메모리에 접근
    - ### 🟥Direct Mapping 문제점
      - ### 🚧메모리 접근 횟수가 2배 ➡ 성능 저하 <br><br> 🚧 PMT를 참조하기 위해 커널 메모리 한번 접근, r 찾아서 메모리 두번 접근 
      - ### ⚠PMT를 위한 메모리 공간 필요
      - ### ✅ 해결방안 ➡ `Associative mapping`
    ------
    - ### 🔸Associative mapping (연관 매핑)
      - <img src="https://user-images.githubusercontent.com/35948339/130832732-663204d3-588c-46eb-be27-b17fd82f5590.png" width=700> 
      - ### 🔹TLB (Translation Look-aside Buffer)에 PMT 저장 (💾PMT를 위한 추가 하드웨어)
      - ### 🔹PMT를 병렬 탐색 할 수 있다
      - ### 🔹낮은 오버헤드, 빠른 탐색 속도
      - ### 🟥TLB가 비싸므로 PMT의 크기에 한계가 있다
      - ### ✅해결책 ➡ Direct + Associative 
    ------
    - ### 🔸Hybrid direct/associative mapping
      - ### 🔹Direct + Associative 혼합하여 사용
        - ### HW 비용은 줄이고, Associative 장점 활용
      - ### 🔹작은 크기의 TLB 사용
        - ### ✅ PMT : 커널 메모리에 저장
        - ### ✅ TLB : PMT 중 일부 entry를 적재
          - ### 최근에 사용된 page들에 대한 entry 저장 ➡ ⭐Locality 활용⭐
        - ### 🚅Locality 활용
          - ### ✅ 한번 접근한 영역을 다시 접근 Or 인접한 영역을 접근할 가능성 높다
      - <img src="https://user-images.githubusercontent.com/35948339/130834312-81304e34-e616-45b6-80ef-0a99173bb2ef.png" width=700> 
      - ### 🔸프로세스의 PMT가 TLB에 적재되어 있는지 확인 하는 방법
        - ### 🔵TLB에 PMT가 있다 ➡ `First trial`
          - ### ✅Residence bit 검사 후, Page frame 번호 확인
        - ### 🟥TLB에 PMT가 없다 ➡ `Second trial`
          - ### `Direct mapping` 으로 Page frame 번호 확인
          - ### 해당 PMT entry를 TLB에 적재
    
    
