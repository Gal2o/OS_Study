## ✔ 가상 메모리 복습
  - ### Non-continuous allocation
    - ### 사용자 프로그램을 block으로 분할하여 적재/실행
  - ### Paging/Segmentation
-------
## ⭐ 가상 메모리 관리의 목적
  - ### 가상 메모리 시스템 성능 최적화
    - ### Cost model
    - ### 다양한 최적화 기법 ‼ (Cost = 오버헤드를 낮추기 위해)
----
## ⭐Cost Model for Virtual Memory
  - ### 🔹 Page fault frequency (발생 빈도)
  - ### 🔹 Page fault rate (발생률)
  - ### ✔ Page fault rate를 최소화 할 수 있도록 전략들을 설계해야 한다
    - ### 🔹 Context Switch 및 Kernel 개입 최소화
    - ### 🔹 시스템 성능 향상
  - ### ⚙ Page reference string (d)
    - ### 프로세스 수행 중 참조한 페이지 번호 순서
    - <img src="https://user-images.githubusercontent.com/35948339/132550542-b32305f4-7568-4b58-bee9-1ff6022d2717.png" width=300>
  - ### ⚙ Page fault rate
    - <img src="https://user-images.githubusercontent.com/35948339/132551014-56a5f8eb-661f-4d34-bcb8-51f23cb33b1d.png" width=300>
  -------
  - ### 🔸 Hardware Components
    - ### 🔹 Address translation device (주소 사상 장치)
      - ### 주소 사상을 효율적으로 수행하기 위해 사용
      - ### ex. TLB, Cache
    - ### 🔹 Bit Vectors
      - ### Page 사용 상황에 대한 정보를 기록하는 비트들
      - <img src="https://user-images.githubusercontent.com/35948339/132552001-a820b66c-e572-4bf1-82bb-d357746c4167.png" height=500>
      - ### ✔ Reference bits = used bits (참조 비트)
        - ### 메모리에 적재된 각각의 page가 `최근`⭐에 참조 되었는지 표시 ≑ `Locality` <br><br> 1️⃣ 프로세스에 의해 참조되면 해당 page의 참조 비트를 1로 설정 <br><br> 2️⃣ 주기적으로 모든 참조비트를 0으로 초기화
      - ### ✔ Update bits = modified = write = dirty (갱신 비트)
        - ### Page가 메모리에 적재된 후, 프로세스에 의해 수정 되었는지 표시
        - ### ‼ 주기적으로 갱신 비트는 초기화 하지 않는다 ❌
        - ### Update bit = 1 
          - ### 해당 page의 (Main memory의 내용) ≠ (Swap device의 내용)
          - ### 해당 page에 대한 Write-back (to swap device)가 필요하다
          - #### ⭐ 갱신비트가 필요한 이유 <br><br> 모든 Page는 Swap device에 있고 ➡ 필요한 작업은 메인 메모리에 적재하여 사용한다 <br><br> But ‼ 프로세스가 메모리 상에서 작업을 하다가 Write 작업을 한다면, ⚠ 값이 변경될 것이다 (무결성 깨짐) <br><br> 그러므로, 갱신 비트를 1로 적어주고, Swap device에 반납할 때, 💾 바뀐 값도 같이 반영해준다 (Write-back) <br><br> 그리고 갱신 비트도 0으로 갱신한다
      - ### ‼ Page Frame 갯수 만큼 참조, 갱신 비트가 PMT에 담겨져 있다
  
