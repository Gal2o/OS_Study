## ✔ 가상 메모리 복습
  - ### Non-continuous allocation
    - ### 사용자 프로그램을 block으로 분할하여 적재/실행
  - ### Paging/Segmentation
-------
## ⭐ 가상 메모리 관리의 목적
  - ### 가상 메모리 시스템 성능 최적화
    - ### Cost model
    - ### 다양한 최적화 기법 ‼ (Cost = 오버헤드를 낮추기 위해)
----
## ⭐Cost Model for Virtual Memory
  - ### 🔹 Page fault frequency (발생 빈도)
  - ### 🔹 Page fault rate (발생률)
  - ### ✔ Page fault rate를 최소화 할 수 있도록 전략들을 설계해야 한다
    - ### 🔹 Context Switch 및 Kernel 개입 최소화
    - ### 🔹 시스템 성능 향상
  - ### ⚙ Page reference string (d)
    - ### 프로세스 수행 중 참조한 페이지 번호 순서
    - <img src="https://user-images.githubusercontent.com/35948339/132550542-b32305f4-7568-4b58-bee9-1ff6022d2717.png" width=300>
  - ### ⚙ Page fault rate
    - <img src="https://user-images.githubusercontent.com/35948339/132551014-56a5f8eb-661f-4d34-bcb8-51f23cb33b1d.png" width=300>
  -------
  - ## 🔸 Hardware Components
    - ### 🔹 Address translation device (주소 사상 장치)
      - ### 주소 사상을 효율적으로 수행하기 위해 사용
      - ### ex. TLB, Cache
    - ### 🔹 Bit Vectors
      - ### Page 사용 상황에 대한 정보를 기록하는 비트들
      - <img src="https://user-images.githubusercontent.com/35948339/132552001-a820b66c-e572-4bf1-82bb-d357746c4167.png" height=500>
      - ### ✔ Reference bits = used bits (참조 비트)
        - ### 메모리에 적재된 각각의 page가 `최근`⭐에 참조 되었는지 표시 ≑ `Locality` <br><br> 1️⃣ 프로세스에 의해 참조되면 해당 page의 참조 비트를 1로 설정 <br><br> 2️⃣ 주기적으로 모든 참조비트를 0으로 초기화
      - ### ✔ Update bits = modified = write = dirty (갱신 비트)
        - ### Page가 메모리에 적재된 후, 프로세스에 의해 수정 되었는지 표시
        - ### ‼ 주기적으로 갱신 비트는 초기화 하지 않는다 ❌
        - ### Update bit = 1 
          - ### 해당 page의 (Main memory의 내용) ≠ (Swap device의 내용)
          - ### 해당 page에 대한 Write-back (to swap device)가 필요하다
          - #### ⭐ 갱신비트가 필요한 이유 <br><br> 모든 Page는 Swap device에 있고 ➡ 필요한 작업은 메인 메모리에 적재하여 사용한다 <br><br> But ‼ 프로세스가 메모리 상에서 작업을 하다가 Write 작업을 한다면, ⚠ 값이 변경될 것이다 (무결성 깨짐) <br><br> 그러므로, 갱신 비트를 1로 적어주고, Swap device에 반납할 때, 💾 바뀐 값도 같이 반영해준다 (Write-back) <br><br> 그리고 갱신 비트도 0으로 갱신한다
      - ### ‼ Page Frame 갯수 만큼 참조, 갱신 비트가 PMT에 담겨져 있다
--------
  - ## 🔸 Software Components
    - ### 🔹 Allocation 전략
      - ### ✔ 각 프로세스에게 메모리를 얼마 만큼 줄 것인가?
        - ### ◻ Fixed allocation (고정 할당)
          - ### 🔵 프로세스의 실행 동안 고정된 크기의 메모리 할당
        - ### ◻ Variable allocation (가변 할당)
          - ### 🔵 프로세스의 실행 동안 할당하는 메모리가 유동적이다
      - ### ⚠ 고려사항
        - ### 🚧 프로세스 실행에 필요한 메모리 양을 예측해야 한다 
        - ### ❌ 너무 큰 메모리 ➡ 메모리 낭비 / ❌ 너무 적은 메모리 ➡ Page fault ⏫
    --------
    - ### 🔹 Fetch 전략
      - ### ✔ 특정 Page를 메모리에 언제 적재할 것인가?
        - ### ◻ Demand fetch (demand paging)
          - ### 🔵 프로세스가 참조하는 페이지들만 적재
          - ### 🟥 Page fault overhead
        - ### ◻ Anticipatory fetch (pre-paging)
          - ### ex. 만화방에서 만화책을 한 번에 여러 권 들고와서 읽는 느낌
          - ### 🔵 참조 될 가능성이 높은 Page 예측하여 적재
          - ### 예측 성공 시, Page fault overhead 가 적다
          - ### 🟥 Prediction overhead (`Kernel의 개입`), ‼ Hit ratio에 민감하다
      - ### ✅ 실제 대부분은 Demand fetch 기법 사용
        - ### 🔵 일반적으로 준수한 성능
        - ### ❌ Anticipatory fetch의 예측 실패 시, 자원 낭비가 크다
    ---------
    - ### 🔹 Placement 전략
      - ### ◻ Page/Segment를 어디에 적재할 것인가?
        - ### ❗ Page 시스템은 불필요하다 (모두가 같은 page frame)
        - ### Segmentation 배치
          - #### First-fit
          - #### Best-fit
          - #### Worst-fit
          - #### Next-fit
    ---------
    - ### 🔹 Replacement 전략
      - ### 새로운 Page를 어떤 Page와 교체할 것인가? (⭐ `빈 Page frame이 없었을 경우`)
    --------
    - ### 🔹 Cleaning 전략
      - ### 변경 된 Page를 언제 `write-back` 할 것인가 (`update, dirty - bit`)
        - ### 🔵 변경된 내용을 swap device에 반영 <br><br> (‼ 메모리에서 작업 후, write 작업 뒤엔 swap device의 데이터와 다를 수 있다)
        - ### Demand cleaning 
          - ### 🔵 해당 Page에 메모리에서 내려올 때, write-back
        - ### Anticipatory cleaning (pre-cleaning)
          - ### 🔵 더 이상 변경 될 가능성이 없다고 판단 할 때, 미리 write-back
          - ### Page 교체 시, 발생하는 write-back 시간 절약
          - ### ❌ write-back 이후, page 내용이 수정되면 overhead
      - ### ✔ 실제 대부분은 마찬가지로, Demand Cleaning 기법 사용
        - ### 🔵 일반적으로 준수한 성능
        - ### ❌ Anticipatory fetch의 예측 실패 시, 자원 낭비가 크다
    -------
    - ### 🔹 Load Control 전략
      - ### ✔ 시스템의 multi-programming degree 조절
        - ### ❗ Allocation 전략과 연계된다
      - <img src="https://user-images.githubusercontent.com/35948339/133301813-97eeaaab-453c-4ffb-a119-dddd0ef01904.png" width=700>
      - ### ♻ 적정 수준의 multi-programming degree를 유지 해야 한다
        - ### 🔵 Plateau(고원) 상태 유지가 Best 
        - ### ❌ 저부하 상태로 유지한다면, 시스템 자원 낭비 & 성능 저하
        - ### ❌ 고부하 상태로 유지한다면, 자원 경쟁 심화 & 성능 저하 & `Thrashing(과도한 page fault) 발생`
  
