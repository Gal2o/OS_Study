## ✔ 가상 메모리 복습
  - ### Non-continuous allocation
    - ### 사용자 프로그램을 block으로 분할하여 적재/실행
  - ### Paging/Segmentation
-------
## ⭐ 가상 메모리 관리의 목적
  - ### 가상 메모리 시스템 성능 최적화
    - ### Cost model
    - ### 다양한 최적화 기법 ‼ (Cost = 오버헤드를 낮추기 위해)
----
## ⭐Cost Model for Virtual Memory
  - ### 🔹 Page fault frequency (발생 빈도)
  - ### 🔹 Page fault rate (발생률)
  - ### ✔ Page fault rate를 최소화 할 수 있도록 전략들을 설계해야 한다
    - ### 🔹 Context Switch 및 Kernel 개입 최소화
    - ### 🔹 시스템 성능 향상
  - ### ⚙ Page reference string (d)
    - ### 프로세스 수행 중 참조한 페이지 번호 순서
    - <img src="https://user-images.githubusercontent.com/35948339/132550542-b32305f4-7568-4b58-bee9-1ff6022d2717.png" width=300>
  - ### ⚙ Page fault rate
    - <img src="https://user-images.githubusercontent.com/35948339/132551014-56a5f8eb-661f-4d34-bcb8-51f23cb33b1d.png" width=300>
  -------
  - ## 🔸 Hardware Components
    - ### 🔹 Address translation device (주소 사상 장치)
      - ### 주소 사상을 효율적으로 수행하기 위해 사용
      - ### ex. TLB, Cache
    - ### 🔹 Bit Vectors
      - ### Page 사용 상황에 대한 정보를 기록하는 비트들
      - <img src="https://user-images.githubusercontent.com/35948339/132552001-a820b66c-e572-4bf1-82bb-d357746c4167.png" height=500>
      - ### ✔ Reference bits = used bits (참조 비트)
        - ### 메모리에 적재된 각각의 page가 `최근`⭐에 참조 되었는지 표시 ≑ `Locality` <br><br> 1️⃣ 프로세스에 의해 참조되면 해당 page의 참조 비트를 1로 설정 <br><br> 2️⃣ 주기적으로 모든 참조비트를 0으로 초기화
      - ### ✔ Update bits = modified = write = dirty (갱신 비트)
        - ### Page가 메모리에 적재된 후, 프로세스에 의해 수정 되었는지 표시
        - ### ‼ 주기적으로 갱신 비트는 초기화 하지 않는다 ❌
        - ### Update bit = 1 
          - ### 해당 page의 (Main memory의 내용) ≠ (Swap device의 내용)
          - ### 해당 page에 대한 Write-back (to swap device)가 필요하다
          - #### ⭐ 갱신비트가 필요한 이유 <br><br> 모든 Page는 Swap device에 있고 ➡ 필요한 작업은 메인 메모리에 적재하여 사용한다 <br><br> But ‼ 프로세스가 메모리 상에서 작업을 하다가 Write 작업을 한다면, ⚠ 값이 변경될 것이다 (무결성 깨짐) <br><br> 그러므로, 갱신 비트를 1로 적어주고, Swap device에 반납할 때, 💾 바뀐 값도 같이 반영해준다 (Write-back) <br><br> 그리고 갱신 비트도 0으로 갱신한다
      - ### ‼ Page Frame 갯수 만큼 참조, 갱신 비트가 PMT에 담겨져 있다
--------
  - ## 🔸 Software Components
    - ### 🔹 Allocation 전략
      - ### ✔ 각 프로세스에게 메모리를 얼마 만큼 줄 것인가?
        - ### ◻ Fixed allocation (고정 할당)
          - ### 🔵 프로세스의 실행 동안 고정된 크기의 메모리 할당
        - ### ◻ Variable allocation (가변 할당)
          - ### 🔵 프로세스의 실행 동안 할당하는 메모리가 유동적이다
      - ### ⚠ 고려사항
        - ### 🚧 프로세스 실행에 필요한 메모리 양을 예측해야 한다 
        - ### ❌ 너무 큰 메모리 ➡ 메모리 낭비 / ❌ 너무 적은 메모리 ➡ Page fault ⏫
    --------
    - ### 🔹 Fetch 전략
      - ### ✔ 특정 Page를 메모리에 언제 적재할 것인가?
        - ### ◻ Demand fetch (demand paging)
          - ### 🔵 프로세스가 참조하는 페이지들만 적재
          - ### 🟥 Page fault overhead
        - ### ◻ Anticipatory fetch (pre-paging)
          - ### ex. 만화방에서 만화책을 한 번에 여러 권 들고와서 읽는 느낌
          - ### 🔵 참조 될 가능성이 높은 Page 예측하여 적재
          - ### 예측 성공 시, Page fault overhead 가 적다
          - ### 🟥 Prediction overhead (`Kernel의 개입`), ‼ Hit ratio에 민감하다
      - ### ✅ 실제 대부분은 Demand fetch 기법 사용
        - ### 🔵 일반적으로 준수한 성능
        - ### ❌ Anticipatory fetch의 예측 실패 시, 자원 낭비가 크다
    ---------
    - ### 🔹 Placement 전략
      - ### ◻ Page/Segment를 어디에 적재할 것인가?
        - ### ❗ Page 시스템은 불필요하다 (모두가 같은 page frame)
        - ### Segmentation 배치
          - #### First-fit
          - #### Best-fit
          - #### Worst-fit
          - #### Next-fit
    ---------
    - ### 🔹 Replacement 전략
      - ### 새로운 Page를 어떤 Page와 교체할 것인가? (⭐ `빈 Page frame이 없었을 경우`)
      - ### 🟦 Fixed allocatiton
        - ### 1️⃣ Min Algorithm (OPT)
          - ### <img src="https://user-images.githubusercontent.com/35948339/133654184-14f555df-ba05-4a04-b66f-40d2295bdb8d.png" width=600> Page fault = 6
          - ### Minimize `Page fault` frequency ➡ 앞으로 가장 오랫동안 참조되지 않을 Page 교체
          - ### ❌ 실현 불가능한 기법 ➡ Page reference string을 미리 알고 있어야 함
          - ### ✔ 교체 기법 성능 평가 기준으로 사용되곤 함
        - ### 2️⃣ Random Algorithm
          - ### 무작위로 교체할 Page 선택
          - ### Low overhead
        - ### 3️⃣ FIFO Algorithm
          - ### <img src="https://user-images.githubusercontent.com/35948339/133655157-0cb099e6-b431-462e-a35d-b9d1824cec7b.png" width=600> Page fault = 10
          - ### 가장 오래된 Page 교체
          - ### ‼ Page가 적재 된 시간을 기억하고 있어야 함
          - ### ❌ 자주 사용되는 Page가 `교체 될 가능성이 높음` ➡ Locality 고려가 없음
          - ### ⚠ FIFO 이상 현상
            - <img src="https://user-images.githubusercontent.com/35948339/133655428-fdcb4b49-f4bd-471f-b84f-0467048ec8f9.png" width=700>
            - ### 다른 알고리즘 보다 Page fault가 많이 발생해서 Page Frame을 추가했는데 <br><br> ⚠ Page fault 더 발생하는 현상 (Locality 고려 하지 않았기 때문)
        - ### 4️⃣ LRU (Least Recently Used) Algorithm
          - ### <img src="https://user-images.githubusercontent.com/35948339/133656132-3b9b7fe5-e7ce-4c44-b968-7471bac55ad8.png" width=700> Page fault = 7
          - ### 가장 오랫동안 참조되지 않은 Page를 교체 (⭐`Locality 반영`)
          - ### Page 참조 시, 시간을 기록해놔야 한다
          - ### 🟢 Min Algorithm과 근접한 성능 & 가장 많이 사용하는 기법
          - ### 🟥 단점
            - ### Page 참조 시, 시간 기록 (overhead ⏫)
            - ### Loop 실행에 필요한 크기보다 작은 수의 Page frame일 경우, Page fault 급격하게 증가 <br><br> Page reference string = 4 > Page frame = 3 <br><br> ➡ Page frame = 4 로 늘려서 해결
         - ### 5️⃣ LFU (Least Frequently Used) Algorithm
           - ### ![image](https://user-images.githubusercontent.com/35948339/133803161-972d7101-2836-4b0c-b6a6-87ecb4b23ee1.png) Page fault = 7
           - ### 가장 참조 횟수가 적은 Page 교체
           - ### Page 참조 시 마다, 참조 횟수를 누적 시켜야 한다 (overhead)
           - ### Locality 활용
             - ### LRU 대비 적은 overhead
           - 🟥 단점
             - ### 최근 적재된 참조 될 가능성이 높은 Page가 교체 될 가능성이 있음
             - ### 참조 횟수 누적 overhead
          - ### 6️⃣ NUR (Not Used Recently) Algorithm
            - ### ‼ LRU 보다 적은 overhead로 비슷한 성능을 만들자
            - ### Bit Vector 사용 
              - ### ⚙ Reference bit vector(r) (최근에 참조 되었다) <br><br> 💾  Update bit vector(m) (메모리에서 작업 후, Swap device에 데이터가 갱신)
            - ### 교체 순서
              - ### 1️⃣(r, m) = (0, 0) <br><br> 2️⃣(r, m) = (0, 1) <br><br> 3️⃣(r, m) = (1, 0) <br><br> 4️⃣(r, m) = (1, 1)
          - ### 7️⃣ Clock Algorithm
            - <img src="https://user-images.githubusercontent.com/35948339/133805954-4110641b-34f7-45fd-9857-7f3979536d95.png" width=500>
            - ### Reference bit 사용함 ➡ ‼ 주기적인 초기화가 없다
            - <img src="https://user-images.githubusercontent.com/35948339/133806730-247dee23-4869-4881-9c2d-6c6dbac118f2.png" width=600>
            - ### Page frame들을 가르키는 pointer(시계바늘)을 사용하여 교체될 Page를 결정한다
              - ### r=0 인 경우, 교체 Page로 결정
              - ### r=1 인 경우, referecn bit 초기화 후, Pointer(시계바늘) 이동
            - ### ‼ 먼저 적재된 Page가 교체될 가능성이 높음 ≑ `FIFO`
            - ### ‼ reference bit를 사용하여 교체 page 결정 ≑ `LRU or NUR`
           - ### 8️⃣ Second Chance Algorithm
             - <img src="https://user-images.githubusercontent.com/35948339/133807236-158362d1-e0b0-4c1f-88bf-a5a6a8dc06b8.png" width=500>
             - ### (`7️⃣Clock`)과 비슷
             - <img src="https://user-images.githubusercontent.com/35948339/133807305-c73e8c57-c7fb-453e-a193-e6d954ed3758.png" width=600>
             - ### Update bit(m)도 함께 고려한다
               - ### 현재 가르키고 있는 page의 (r, m) 확인
               - ### (0, 0) : 교체 Page로 결정
               - ### (0, 1) : (0, 0) write-back list에 추가 후 이동
               - ### (1, 0) : (0, 0) 후 이동
               - ### (1, 1) : (0, 1) 후 이동
           - ### ✔ 그 밖의 알고리즘
           - <img src="https://user-images.githubusercontent.com/35948339/133807771-709e6b0a-37d2-478c-9c53-2bbec7661c2e.png" width=600>
      - ### 🟦 Variable allocation
    --------
    - ### 🔹 Cleaning 전략
      - ### 변경 된 Page를 언제 `write-back` 할 것인가 (`update, dirty - bit`)
        - ### 🔵 변경된 내용을 swap device에 반영 <br><br> (‼ 메모리에서 작업 후, write 작업 뒤엔 swap device의 데이터와 다를 수 있다)
        - ### Demand cleaning 
          - ### 🔵 해당 Page에 메모리에서 내려올 때, write-back
        - ### Anticipatory cleaning (pre-cleaning)
          - ### 🔵 더 이상 변경 될 가능성이 없다고 판단 할 때, 미리 write-back
          - ### Page 교체 시, 발생하는 write-back 시간 절약
          - ### ❌ write-back 이후, page 내용이 수정되면 overhead
      - ### ✔ 실제 대부분은 마찬가지로, Demand Cleaning 기법 사용
        - ### 🔵 일반적으로 준수한 성능
        - ### ❌ Anticipatory fetch의 예측 실패 시, 자원 낭비가 크다
    -------
    - ### 🔹 Load Control 전략
      - ### ✔ 시스템의 multi-programming degree 조절
        - ### ❗ Allocation 전략과 연계된다
      - <img src="https://user-images.githubusercontent.com/35948339/133301813-97eeaaab-453c-4ffb-a119-dddd0ef01904.png" width=700>
      - ### ♻ 적정 수준의 multi-programming degree를 유지 해야 한다
        - ### 🔵 Plateau(고원) 상태 유지가 Best 
        - ### ❌ 저부하 상태로 유지한다면, 시스템 자원 낭비 & 성능 저하
        - ### ❌ 고부하 상태로 유지한다면, 자원 경쟁 심화 & 성능 저하 & `Thrashing(많은 page fault) 발생`
  
