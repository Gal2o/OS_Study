# Mutual Exclusion Solutions
# Low-level 메커니즘
## SW Solution
  - ## Dekker's Algorithm
    - <img src="https://user-images.githubusercontent.com/35948339/128881092-ece613f2-5dff-4eb3-ad6c-8242fd40cd66.png" width=600>
    - ### 두 개의 프로세스 ME를 보장하는 최초의 알고리즘
    - ### Version 1, 2, 3 보완한 방법
  - ## Peterson's Algorithm
    - <img src="https://user-images.githubusercontent.com/35948339/128881517-b6cd3810-650c-4ddc-b655-9286810b8a38.png" width=600>
    - ### Dekker's Algorithm 보다 간단하게 구현
  - ## Dijkstra's Algorithm
    - ### ⭐ 최초로 프로세스 N개의 ME 해결
    - ### ⭐ 실행 시간이 가장 짧은 프로세스에 CPU를 할당하는 Semaphore 방법 <br><br> ⭐ 가장 짧은 평균 대기시간 제공
    - <img src="https://user-images.githubusercontent.com/35948339/128883255-ba3a87ac-e3d7-484d-aced-9e078d982592.png" width=600>
    - ### ⭐ Dijkstra에서의 flag[]
      - ### ✔ idle : 프로세스가 임계 지역 진입을 시도하고 있지 않을 때
      - ### ✔ want-in : 프로세스의 임계 지역 진입 시도 1단계
      - ### ✔ in-CS : 프로세스의 임계 지역 진입 시도 2단계
        - ### ⭐ in-CS 안에 나 혼자 있으면 임계 영역에 들어가겠다 <br><br> ‼ 만약에 누군가 있었으면, 처음으로 다시 돌아간다
  - ## SW solution 들의 문제점
    - ### 🟥 Dijkstra Solution 처럼 빙빙 도는 현상이 목격 된다
    - ### 🟥 ➡️ 속도가 느리다
    - ### 🟥 구현이 복잡하다
    - ### ‼ ME primitive 실행 중 선점 될 가능성이 있다 ➡️ Interrupt 조절 ➡️ Overhead 발생 ‼
    - ### 🟥 Busy Waiting 발생 ➡️ 자기 차례 올 때까지, 빙빙 돌면서 기다리는 현상

## OS suppored SW Solution
  - ## Spinlock
    - ### ⭐ 정수 변수
    - ### ⭐ 초기화, P(), V() 연산으로만 접근 가능하다
      - ### ✔ 위 연산들은 Indivisible (분리되지 않는) or Atomic 연산 
      - ### ✔ OS가 보장한다
      - ### ✔ 전체가 하나의 Instruction cycle 에 수행된다 ➡️ Preemption 되지 않는다
      - <img src="https://user-images.githubusercontent.com/35948339/128887678-e76ddfc9-fe1f-48ed-a0bb-1486b18069b5.png" width=600>
      - ### P(S) ➡️ 물건을 꺼내 가는 것, 자물쇠를 건다
      - ### V(S) ➡️ 물건을 반납 하는 것, 자물쇠를 푼다
      - <img src="https://user-images.githubusercontent.com/35948339/128888172-a6bc877a-c7e7-4016-b94b-ea0c98e9178f.png" width=600>
      - ### ⭐ active = 1 (임계 지역에 프로세스가 없음) <br><br> 1️⃣ P(S) (자물쇠를 걸고 들어간다) <br><br> 2️⃣ active를 0으로 바꾼다 <br><br> 3️⃣ ❓ 다른 프로세스가 들어오면, active = 0을 보고 진입불가 ❌ <br><br> 4️⃣ 작업을 마치고, V(S) 자물쇠 풀기, active를 0으로 바꾸기
  - ## Spinlock의 문제점
    - ### 🟥 멀티 프로세서 시스템에서만 사용 가능 ‼
      - ### 🚦 프로세서가 1 개라면 <br><br> ️1️⃣ P1이 active를 0으로 만들고 임계 영역 진입 <br><br> 2️⃣ 임계 영역에서 작업 중 🟥 Preemption (P(S), V(S) 작업이 아니므로 Preemption이 가능하다) <br><br> 3️⃣ P2는 CPU 할당 받고, `P(S) { while(S <= 0) }` ▶️ 계속 대기중 <br><br> 4️⃣ P1, P2 모두 작업을 못한다
      - ### 🟥 Busy Waiting ‼ 
      - ### ⭐ 프로세스가 각각 CPU를 할당 받아서 동시에 실행 되어야만 성립 ‼
  - ## Semaphore (‼ Spinlock과 무엇이 다른지 비교)
    - ### ⭐ Dijkstra가 제안
    - ### ⭐ Busy Waiting 문제 해결 ▶️ 기다려야 하는 프로세스는 Block 상태
    - ### ⭐ 음이 아닌 정수형 변수 (S), 초기화 연산, P(), V()
    - ### 🟥 Ready-Queue에 기다리고 있는 프로세스 Wake-up 순서는 랜덤 ▶️ Starvation 가능성 🟥
    - ### ✔ OS가 보장한다
    - ### ✔ 전체가 하나의 Instruction cycle 에 수행된다 ➡️ Preemption 되지 않는다
      - #### 🤷‍♂️ P: Probern (검사), V: Verhogen (증가)
      - #### 🤷‍♂️ 초기화 연산: S 변수에 초기 값 부여
      - <img src="https://user-images.githubusercontent.com/35948339/129046737-b3a4a391-7f46-4233-91f4-2fa258d9598f.png" width=600>
      - #### 🤷‍♂️ P() 연산 <br><br> 1️⃣ `S > 0` (들어갈 수 있으면) ▶️ `S ⬅️ S-1` (자물쇠를 잠근다) <br><br> 2️⃣ `S < 0` (들어갈 수 없으면) ‼ Spinlock처럼 Busy Waiting이 아닌 ready-queue에 가만히 대기 하고 있는다 ‼
      - #### 🤷‍♂️ V() 연산 <br><br> 1️⃣ ready-queue에 기다리고 있는 프로세스 중 하나를 깨운다 <br><br> 2️⃣ `S ⬅️ S+1` 자물쇠를 열고 나간다
    - ### `⭐⭐ 임의의 S 변수 하나에 Ready-Queue 하나가 할당 된다 ⭐⭐`
    - ### 🔵 Binary Semaphor 🔵
      - ### S 가 0 또는 1 두 값만 갖는 경우
      - ### ✔ 상호배제나 프로세스 동기화 목적으로 사용한다
    - ### 🟢 Counting Semaphore 🟢
      - ### S 가 0 이상의 정수 값을 갖는 경우
      - ### Producer-Consumer 문제 등을 해결 하기 위해 사용
    - ## ⭐ Semaphore로 해결 가능한 동기화 문제들
      - ### 🔵 Mutual Exclusion 🔵
        - <img src="https://user-images.githubusercontent.com/35948339/129050582-96f214fe-5aa8-4bde-b11d-c629f450ae03.png" width=600>
      - ### 🔵 Process Synchronization 🔵
        - ### ✔ 프로세스들의 실행 순서 맞추기
        - ### ❗ 프로세스들은 병행적이고, 비동기적으로 수행
        - <img src="https://user-images.githubusercontent.com/35948339/129051576-7cca05e8-dff9-408e-8598-394d6e449c6a.png" width=700>
        - #### 둘 중 하나가 작업 중이라면, L 지점에 도착해서 자원 반납 ➡️ 다음 프로세스가 작업
      - ### 🟢 Producer-Consumer 🟢
        - ### ✔ Producer 프로세스 ▶️ 메시지 생성 그룹
        - ### ✔ Consumer 프로세스 ▶️ 메시지를 받는 프로세스 그룹
        - ### 🟢 단일 버퍼를 가진 Producer-Consumer
          - <img src="https://user-images.githubusercontent.com/35948339/129057075-1a809fb9-ac57-4d28-8250-4dd570ec4996.png" width=600>
          - ### ✔ Producer가 메시지를 보낼 때는 Consumer가 접근 못하고 <br><br> Consumer가 메시지를 받을 때 Producer는 메시지를 보낼 수 없다
          - ### ✔ `P(consumed), (produced)` ➡️ Consumer, Producer가 작업 중? <br><br> ✔ `C(produced), (consumed)` ➡️ Producer, 가 작업 시작 ❗
        - ### 🟢 N개의 버퍼를 가진 Producer-Consumer
          - <img src="https://user-images.githubusercontent.com/35948339/129058298-628107e6-4d1b-449d-897d-7401ddaa96b5.png" width=600>
          - ### ✔ Producer, Consumer 프로세스가 여러 개
      - ### 🟢 Reader-Writer 🟢
        - ### ✔ Reader ▶️ 데이터에 대해 읽기 연산만 수행
        - ### ✔ Writer ▶️ 데이터에 대해 갱신 연산을 수행
        - ### ⭐ 데이터 무결성 보장 필요
          - ### ⭐ Reader들은 동시에 데이터에 접근 가능하다
          - ### ⭐ Writer 또는 (Reader와 Writer) 가 동시 데이터 접근 시, 상호배제(동기화)가 필요하다
        - ### ✔ 해결법 ▶️▶️ Reader/Writer 에 대한 우선권 부여
        - <img src="https://user-images.githubusercontent.com/35948339/129218951-983c2c5d-1c78-44ec-9c39-6680186c34cd.png" width=600>
        - ### Reader 우선권 Solutuon
      - ### 🤷‍♂️ Dining Philosopher (철학자들의 저녁식사)
  - ## Eventcount / Sequencer
    - ### ✔ 은행의 번호표와 비슷한 개념
    - ### ⭐ Sequencer (번호표 뽑는 기계)
      - <img src="https://user-images.githubusercontent.com/35948339/129220994-69fe32bd-9840-43c5-a858-898b748d6f50.png" width=300>
      - ### ✔ 정수형 변수
      - ### ✔ 생성시 0으로 초기화, 감소하지 않는다 ▶️ 번호가 계속 증가한다
      - ### ✔ 발생 사건들의 순서 유지
      - ### ✔ ticket() 연산으로만 접근 가능
    - ### ⭐ ticket(S) (번호표)
      - ### ✔ 현재까지 ticket() 연산이 호출 된 횟수를 반환
      - ### ✔ 위 연산들은 Indivisible (분리되지 않는) or Atomic 연산 
    - ### ⭐ Eventcount
      - <img src="https://user-images.githubusercontent.com/35948339/129221322-32e8c372-9843-48a4-addb-d10ce7009fa5.png" width=300>
      - ### ✔ 정수형 변수
      - ### ✔ 생성 시 0으로 초기화, 감소하지 않는다 ▶️ 번호가 계속 증가한다
      - ### ✔ 특정 사건의 발생 횟수를 기록
      - ### ✔ read(E), advance(E), await(E,v) 연산으로만 접근 가능
    - ### 🟢 read(E) (자신의 번호를 확인한다)
      - ### ✔ 현재 Eventcount 값 반환
    - ### 🟢 advance (E) (은행원이 번호를 눌러서 호출)
      - ### ✔ E ◀️ E + 1
      - ### ✔ E를 기다리고 있는 프로세스를 깨움
    - ### 🟢 await(E, v) (Eventcount(E) 가 10번인데 < 내 번호(v) 가 15라면, 대기)
      - ### ✔ v는 정수형 변수
      - ### ✔ `if (E < v)` 이면 E에 연결된 ready-queue에 프로세스 전달 및 <br><br> 순서가 되면 Scheduler에게 깨워달라고 요청한다
    - ## ⭐ Mutual Exclusion 해결법
      - <img src="https://user-images.githubusercontent.com/35948339/129222896-ec3b8368-a1f1-4c0c-add1-68ab1f528ffe.png" width=600>
      - ### 1️⃣ `v ◀️ ticket(S)` 번호표를 뽑고 S ◀️ S + 1 <br><br> 2️⃣ `await(E, v)` 자신의 번호가 올 때 까지 기다리다가, <br><br> 3️⃣ CS에 진입해서 작업 하고, <br><br> 4️⃣ 은행원이 E ◀️ E + 1 하고, 다음 E 프로세스를 깨운다
      - ### ⭐ Semaphore에서의 문제점 Starvation이 해결된다 ▶️ 순서대로 프로세스를 처리하기 때문 ❗
    - ## ⭐ Producer-Consumer 해결법
      - <img src="https://user-images.githubusercontent.com/35948339/129224157-5b8444a0-c8bb-4d9e-9ded-9f1c62daf308.png" width=600>
      - ### ✅ Pticket : 프로듀서 /  Cticket : 컨슈머
      - ### ✅ In : 물건을 놓는 이벤트 / Out : 물건을 꺼내는 이벤트
      - ### ✅ 크기가 N인 원형 buffer
      - ### 🔵 프로듀서 🔵 <br><br> 1️⃣ Create M 하고 `t ◀️ ticket(Pticket)` Pticket을 뽑고 <br><br> `await(In, t)` 내 차례가 되면 CS에 진입한다 <br><br> 2️⃣ `await(Out, t-N+1)` M이 들어갈 공간이 없으면 기다리고, 공간이 있다면, <br><br> `buffer[t mod N] ◀️ M` M을 버퍼에 놓고 <br><br> 3️⃣ 다음 In에게 차례 넘겨주기
      - ### 🟢 컨슈머 🟢 <br><br> 1️⃣ `u ◀️ ticket(Cticket)` Cticket을 뽑고, <br><br> `await(Out, u)` 내 차례가 되면 CS에 진입한다 <br><br> 2️⃣ `await(In, u+1)` 물건이 없으면 기다리고,  물건이 있다면 <br><br> `m ◀️ buffer[u mod N]` M을 읽고 <br><br> 3️⃣ 다음 Out에게 차례 넘겨주기
    - ### 🔵 No Busy Waiting 
    - ### 🔵 No Starvation ▶️ FIFO Scheduling for QE
-----
# High-level 메커니즘
## Languague-Level Solution
  - ### ✅ Language-level에서 지원
  - ### ✅ 사용이 쉽다
  - ### ❌ 지원하는 언어에서만 사용 가능 ❌
  - ### ❌ 컴파일러가 OS를 이해하고 있어야 함 ❌
  - ## Monitor
    - <img src="https://user-images.githubusercontent.com/35948339/129734753-bde39a02-af21-4301-9908-6326f0bfd328.png" width=700>
    - ### ⭐ Monitor ▶️ `공유 데이터와 Critical Section의 집합`
    - ### ⭐ Conditinal variable
      - ### 🔵 wait(), signal() operations
    - ### 1️⃣ Entry queue (진입 큐)
      - ### ✅ 모니터 내의 procedure (function) 수만큼 존재
    - ### 2️⃣ Mutual exclusion (Languague-Level에서 지원하여 쉽게 가능)
      - ### ⭐ 모니터 내에는 `항상 하나` 의 프로세스만 진입 가능 ⭐
    - ### 3️⃣ Information hiding (정보 은폐)
      - ### ⭐ 공유 데이터는 모니터의 내의 프로세스만 접근 가능하다
    - ### 4️⃣ Condition queue (조건 큐 ▶️ 프로세스 수와 같다)
      - ### ⭐ 모니터 내의 특정 이벤트를 기다리는 프로세스가 대기
    - ### 5️⃣ Signaler queue (신호 제공자 큐)
      - ### ⭐ ex. 전화 부스 ▶️ Condition queue에 전화를 걸어서 이제 대기 안해도 된다고 말함
      - ### ⭐ 모니터에는 항상 하나의 Signaler queue 가 존재한다
      - ### signal() 명령을 실행한 `프로세스` 가 임시 대기
  - ## Monitor의 활용
    - ### 자원 할당 문제
      - <img src="https://user-images.githubusercontent.com/35948339/129743086-34883478-905b-4bf8-a284-05be75cdcc92.png" height=400>
      - ### 🔹 R_Available ▶️ R 1개를 한 번에 한 명씩 쓸 수 있게 자원 할당 (ex. 책)
      - ### 🔹 releaseR() ▶️ R 을 반납 (ex. 책 반납)
      - ### 🔹 requestR() ▶️ R 을 할당 (ex. 책 대여)
      - ### 🔹 R_Free ▶️ R이 free일 때를 기다리는 condition queue (ex. 책을 빌릴 수 있는지 대기하는 공간)
      - ### 🔹 signaler queue ▶️ R_Free에 대기하고 있는 프로세스를 깨우는 queue
    - ### Producer-Consumer 문제
      - <img src="https://user-images.githubusercontent.com/35948339/129743597-67c1b7c3-0bd1-40d6-b449-eed1e1537830.png" height=500>
    - ### Reader-Writer 문제
      - <img src="https://user-images.githubusercontent.com/35948339/129743752-e6b7b842-bab4-4002-992e-63ea5a740a1e.png" height=500>
    - ### 식사하는 철학자 문제
      - <img src="https://user-images.githubusercontent.com/35948339/129743922-eb8fdc0a-bb2a-481d-822b-38c48907f346.png" height=450> <img src="https://user-images.githubusercontent.com/35948339/129744645-0f115a38-c38b-4dde-b663-32409c698b31.png" width=300>
      - ### 🔹 5 명의 철학자 ▶️ ⭐ 프로세스 갯수 ⭐
      - ### 🔹 철학자들은 생각하는 일, 스파게티 먹는 일만 반복한다
      - ### 🔹 공유 자원 ▶️ 스파케티, 포크
      - ### 🔹 스파게티를 먹기 위해서는 양손 포크 2개를 들어야 한다 but 주어진 포크는 5개
    
