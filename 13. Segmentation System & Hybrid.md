# 🔸 Segmentation System (Non-Continuous allocation)
  - <img src="https://user-images.githubusercontent.com/35948339/131689824-59c230f6-610d-4805-bbd3-c87a0a3e97af.png" width=700>
  - ## 🔹 프로그램을 논리적 block으로 분할 (segment)
    - ### Block의 크기가 서로 다르다 <br><br> Ex. stack, heap, main procedure, shared lib, Etc.
  - ## ↔ ‼ Paging System은 같은 크기의 page frame으로 비연속적인 할당으로 사용했었다
  - ## 🔹 특징
    - ### ✔ 메모리를 미리 분할 하지 않는다 (Variable Partition Multi-programming 과 유사)
    - ### ✔ Segment sharing / protection 이 편하다 🟥 그만큼 메모리 관리의 `Overhead`가 크다
    - ### ⭐ `내부 단편화`가 발생하지 않는다 <br><br> ❌ `외부 단편화`가 발생할 수 있다.
    - ### ❌ Segment mapping overhead
      - ### 메모리 공간 및 추가적인 메모리 접근 필요
      - ### 전용 HW활용으로 해결 가능 (TLB, Hybrid)
------
  - ## 🔸 Address Mapping
    - ### 🔹 Virtual address : ```v = (s,d)```
      - ### s : segment number
      - ### d : offset
    - ### 🔹 Segment Map Table (SMT)
    - <img src="https://user-images.githubusercontent.com/35948339/131690992-fa5786da-939e-4ea1-b372-6e784b129fe7.png" width=700>
    - ### 1️⃣ `Segment length` : 각자 segment 마다 길이가 다르므로 적어놔야 한다 <br><br> 2️⃣ `protection bits`가 추가 되었다
    - ## 🔸 Direct Mapping <br><br> <img src="https://user-images.githubusercontent.com/35948339/131692410-bd5b4ce3-f791-40c3-bdcc-0bdc5d3074a2.png" width=700>
    - ### ⭕ Paging System과 유사하게 실제 주소를 찾아가면 된다
    - ### 1️⃣ 프로세스의 SMT가 저장되어 있는 주소 b에 접근
    - ### 2️⃣ SMT에서 segment s의 entry 찾음 <br><br> s의 entry 위치 = ```b + s*entrySize```
    - ### 3️⃣ 찾아진 entry에 대해 다음 단계들을 순차적으로 실행
      - ### ❌ residence bit가 0인 경우 ➡ swap device로 부터 segment 메모리에 적재 ➡ SMT 갱신 
      - ### ❌ offset d가 segment 길이보다 큰 경우 (d > l) ➡ ⚠ `segment overflow` exception 호출 
      - ### ❌ 허가 되지 않은 연산일 경우 (protection bit) ➡ ⚠ `segment protection` exception 호출
    - ### 4️⃣ 실제 주소 r 계산 ```r = a+d```
    - ### 5️⃣ r 주소의 메모리 접근 성공
    - -----
    - ## 🔸 Memory management 
      - <img src="https://user-images.githubusercontent.com/35948339/131694674-b63554a6-c37e-4d97-9394-14e0f1d9f67b.png" width=600>
      - ### ✔ Variable Partition Multi-programming과 유사
        - ### Segment 적재 시, 크기에 맞추어 분할 후 적재
    - -----
    - ## 🔸 Segment sharing & protection
      - <img src="https://user-images.githubusercontent.com/35948339/131695079-ff2137ec-a8bb-40d6-8582-d3bf39e3d087.png" width=600>
      - ### ✔ 논리적으로 분할되어 있어, 공유 및 보호가 용이하다
      - <img src="https://user-images.githubusercontent.com/35948339/131696836-b5ef2ccc-8ff0-4581-9a90-92d0a0ecb30e.png" height=200>
      - ### ✔ 공유를 할 때도, 논리적으로 나눠 놨기 때문에, 어떤 주소에서도 올바르게 jump를 한다
-----
# 🔸 Hybrid Paging/Segmentation System
  - ## ⭐ Paging과 Segmentation의 장점 결합
    - <img src="https://user-images.githubusercontent.com/35948339/131700562-f5b3b9c6-6606-4393-a553-a3b5099fd68d.png" width=600>
    - ### 🔹 프로그램 분할
      - ### 1️⃣ 논리 단위의 segment의 분할
      - ### 2️⃣ 각 segment를 고정된 크기의 page들로 분할
      - ### 💾 Page 단위로 메모리에 적재
    ------
    - ### 🔸 Address Mapping
      - ### 🔹 Virtual address : v = (s, p, d)
        - ### s : segment number
        - ### p : page number
        - ### d : offset in a page
      - ### 🔹 `SMT와 PMT 모두 사용`
      - ### ✔ SMT
      - <img src="https://user-images.githubusercontent.com/35948339/131701053-a81a5152-bac8-4b33-912d-cd36daa7b52d.png" width=500>
      - ### ✔ PMT
      - <img src="https://user-images.githubusercontent.com/35948339/131701088-c9886594-0b43-4273-b7ad-0aee68c7298f.png" width=500>
      - ### 🔹 Adress mapping
        - <img src="https://user-images.githubusercontent.com/35948339/131701433-0e41e8b4-25f0-49c7-877a-1691c4732a25.png" width=600>
        - ### 💾 Direct Mapping
        - <img src="https://user-images.githubusercontent.com/35948339/131701730-1adb9ffa-f3a5-4882-83f7-01664873a7e1.png" width=600>
        - ### 🔹 Associated Mapping
      - ### 🔹 메모리 관리 (FPM과 유사) 
   - ## 🔸 Hybrid 결론
     - ### ⭐ 논리적 분할 (segment)와 고정 크기 분할 (page)을 결합
       - ### 1️⃣ Page sharing / protection 쉬움
       - ### 2️⃣ 메모리 할당 / 관리 overhead가 작음
       - ### 3️⃣ `외부 단편화 ❌, 내부 단편화 ⭕`
     - ### 🟥 전체 테이블 수 증가
       - ### 메모리 소모가 큼
       - ### Address mapping 과정이 복잡하다
     - ### 🟥 Direct mapping의 경우, 메모리 접근이 3배
       - ### 성능이 저하될 수 있다
